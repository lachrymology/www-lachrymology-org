<!DOCTYPE html>
<html lang="en"> 
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>The Early History of Smalltalk</title>
    <link href='http://fonts.googleapis.com/css?family=Cardo:400,700,400italic' rel='stylesheet' type='text/css'>

    <link type="text/css" rel="stylesheet" media="all" href="../../default.css" />
  </head>

  <body>
    <div id="body">
      <div id="content">

	<h1><a href="/">lachrymology</a></h1>

	<ul id="posts">
	  <li class="post">
	    <div class="post-body text-post">
	      <h3>The Early History of Smalltalk</h3>
	      <p><a href='SmalltalkHistoryHOPL.pdf'>original pdf</a> / <a href='https://github.com/worrydream/EarlyHistoryOfSmalltalk'>make corrections</a></p>

<h1 id='the_early_history_of_smalltalk'>The Early History Of Smalltalk</h1>

<p><em>Alan C. Kay</em><br /><em>Apple Computer</em><br /><em>kay2@apple.com.Internet#</em></p>

<p>Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission.<br />HOPL-II/4/93/MA, USA (C) 1993 ACM 0-89791-571-2/93/0004/0069&#8230;$1.50</p>

<h2 id='abstract'>Abstract</h2>

<p>Most ideas come from previous ideas. The sixties, particularly in the ARPA community, gave rise to a host of notions about &#8220;human-computer symbiosis&#8221; through interactive time-shared computers, graphics screens and pointing devices. Advanced computer languages were invented to simulate complex systems such as oil refineries and semi-intelligent behavior. The soon-to-follow paradigm shift of modern personal computing, overlapping window interfaces, and object-oriented design came from seeing the work of the sixties as something more than a &#8220;better old thing.&#8221; This is, more than a better way: to do mainframe computing; for end-users to invoke functionality; to make data structures more abstract. Instead the promise of exponential growth in computing /$/ volume demanded that the sixties be regarded as &#8220;_almost_ a new thing&#8221; and to find out what the actual &#8220;new things&#8221; might be. For example, one would compute with a handheld &#8220;Dynabook&#8221; in a way that would not be possible on a shared mainframe; millions of potential users meant that the user interface would have to become a learning environment along the lines of Montessori and Bruner; and needs for large scope, reduction in complexity, and end-user literacy would require that data and control structures be done away with in favor of a more biological scheme of protected universal cells interacting only through messages that could mimic any desired behavior.</p>

<p>Early Smalltalk was the first complete realization of these new points of view as parented by its many predecessors in hardware, language and user interface design. It became the exemplar of the new computing, in part, because we were actually trying for a qualitative shift in belief structures&#8211;a new Kuhnian paradigm in the same spirit as the invention of the printing press&#8211;and thus took highly extreme positions which almost forced these new styles to be invented.</p>

<h2 id='table_of_contents'>Table of Contents</h2>

<p>* Introduction 2 * I. 1960-66&#8211;Early OOP and other formative ideas of the sixties 4</p>

<pre><code>* B220 File System
* SketchPad &amp; Simula</code></pre>

<p>* II 1967-69&#8211;The FLEX Machine, an OOP-based personal computer 6</p>

<pre><code>* Doug Englebart and NLS
* Plasma Panel, GRAIL, LOGO, Dynabook</code></pre>

<p>* III. 1970-72&#8211;Xerox PARC 12</p>

<pre><code>* KiddiKomp
* miniCOM
* Smalltalk-71
* Overlapping Windows
* Font Editing, Painting, Animation, Music
* Byte Codes
* Iconic Programming</code></pre>

<p>* IV. 1972-76&#8211;Xerox PARC: The first real Smalltalk (-72) 17</p>

<pre><code>* The two bets: birth of Smalltalk and Interim Dynabook
* Smalltalk-72 Principles
* The Smalltalk User Interface
* Development of the Smalltalk Applications &amp; System
* Evolution of Smalltalk: ST-74, ooze storage management
* Smalltalk and Children</code></pre>

<p>* V. 1976-80&#8211;The first modern Smalltalk (-76) 29</p>

<pre><code>* &quot;Let&#39;s burn our disk packs&quot;
* The Notetaker
* Smalltalk-76
* Inheritance
* More Troubles With Xerox
* ThingLab
* Apple Demo</code></pre>

<p>* VI. 1980-83&#8211;The release version of Smalltalk (-80) 38</p>

<pre><code>* Transformations
* Coda</code></pre>

<p>* References Cited in Text 41 * Appendix I: KiddiKomp Memo 45 * Appendix II: Smalltalk-72 Interpreter Design 47 * Appendix III: Acknowledgments 50 * Appendix IV: Event Driven Loop Example 53 * Appendix V: Smalltalk-76 Internal Structures 54</p>

<p>&#8211;To Dan Ingalls, Adele Goldberg and the rest of Xerox PARC LRG gang</p>

<p>&#8211;To Dave Evens, Bob Barton, Marvin Minsky, and Seymour Papert</p>

<p>&#8211;To SKETCHPAD, JOSS, LISP, and SIMULA, the 4 great programming conceptions of the sixties</p>

<h2 id='introduction'>Introduction</h2>

<p>I&#8217;m writing this introduction in an airplane at 35,000 feet. On my lap is a five pound notebook computer&#8211;1992&#8217;s &#8220;Interim Dynabook&#8221;&#8211;by the end of the year it sold for under $700. It has a flat, crisp, high-resolution bitmap screen, overlapping windows, icons, a pointing device, considerable storage and computing capacity, and its best software is object-oriented. It has advanced networking built-in and there are already options for wireless networking. Smalltalk runs on this system, and is one of the main systems I use for my current work with children. In some ways this is more than a Dynabook (quantitatively), and some ways not quite there yet (qualitatively). All in all, pretty much what was in mind during the late sixties.</p>

<p>Smalltalk was part of this larger pursuit of ARPA, and later of Xerox PARC, that I called <em>personal computing.</em> There were so many people involved in each stage from the research communities that the accurate allocation of credit for ideas is intractably difficult. Instead, as Bob Barton liked to quote Goethe, we should &#8220;share in the excitement of discovery without vain attempts to claim priority.&#8221;</p>

<p>I will try to show where most of the influences came from and how they were transformed in the magnetic field formed by the new personal computing metaphor. It was the <em>attitudes</em> as well as the great ideas of the pioneers that helped Smalltalk get invented. Many of the people I admired most at this time&#8211;such as Ivan Sutherland, Marvin Minsky, Seymour Papert, Gordon Moore, Bob Barton, Dave Evans, Butler Lampson, Jerome Bruner, and others&#8211;seemed to have a splendid sense that their creations, though wonderful by relative standards, were not near to the absolute thresholds that had to be crossed. Small minds try to form religions, the great ones just want better routes up the mountain. Where Newton said he saw further by standing on the shoulders of giants, computer scientists all too often stand on each other&#8217;s toes. Myopia is still a problem where there are giants&#8217; shoulders to stand on&#8211;&#8220;outsight&#8221; is better than insight&#8211;but it can be minimized by using glasses whose lenses are highly sensitive to esthetics and criticism.</p>

<p>Programming languages can be categorized in a number of ways: imperative, applicative, logic-based, problem-oriented, etc. But they all seem to be either an &#8220;agglutination of features&#8221; or a &#8220;crystallization of style.&#8221; COBOL, PL/1, Ada, etc., belong to the first kind; LISP, APL&#8211; and Smalltalk&#8211;are the second kind. It is probably not an accident that the agglutinative languages all seem to have been instigated by committees, and the crystallization languages by a single person.</p>

<p>Smalltalk&#8217;s design&#8211;and existence&#8211;is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages. Philosophically, Smalltalk&#8217;s objects have much in common with the monads of Leibniz and the notions of 20th century physics and biology. Its way of making objects is quite Platonic in that some of them act as idealizations of concepts&#8211;_Ideas_&#8211;from which <em>manifestations</em> can be created. That the Ideas are themselves manifestations (of the Idea-Idea) and that the Idea-Idea is <em>a-kind-of</em> Manifestation-Idea&#8211;which is a-kind-of itself, so that the system is completely self-describing&#8211; would have been appreciated by Plato as an extremely practical joke (Plato).</p>

<p>In computer terms, Smalltalk is a recursion on the notion of computer itself. Instead of dividing &#8220;computer stuff&#8221; into things each less strong than the whole&#8211;like data structures, procedures, and functions which are the usual paraphernalia of programming languages&#8211;each Smalltalk object is a recursion on the entire possibilities of the computer. Thus its semantics are a bit like having thousands and thousands of computers all hooked together by a very fast network. Questions of concrete representation can thus be postponed almost indefinitely because we are mainly concerned that the computers behave appropriately, and are interested in particular strategies only if the results are off or come back too slowly.</p>

<p>Though it has noble ancestors indeed, Smalltalk&#8217;s contribution is a new design paradigm&#8211;which I called <em>object-oriented</em>&#8211;for attacking large problems of the professional programmer, and making small ones possible for the novice user. Object-oriented design is a successful attempt to qualitatively improve the efficiency of modeling the ever more complex dynamic systems and user relationships made possible by the silicon explosion.</p>

<p>&#8220;We would know what they thought<br />when they did it.&#8221;<br />&#8211;Richard Hamming</p>

<p>&#8220;Memory and imagination are but two<br />words for the same thing.&#8221;<br />&#8211;Thomas Hobbes</p>

<p>In this history I will try to be true to Hamming&#8217;s request as moderated by Hobbes&#8217; observation. I have had difficulty in previous attempts to write about Smalltalk because my emotional involvement has always been centered on personal computing as an amplifier for human reach&#8211;rather than programming system design&#8211;and we haven&#8217;t got there yet. Though I was the instigator and original designer of Smalltalk, it has always belonged more to the people who make it work and got it out the door, especially Dan Ingalls and Adele Goldberg. Each of the LRGers contributed in deep and remarkable ways to the project, and I wish there was enough space to do them all justice. But I think all of us would agree that for most of the development of Smalltalk, Dan was the central figure. Programming is at heart a practical art in which real things are built, and a real implementation thus has to exist. In fact many if not most languages are in use today not because they have any real merits but because of their existence on one or more machines, their ability to be bootstrapped, etc. But Dan was far more than a great implementer, he also became more and more of the designer, not just of the language but also of the user interface as Smalltalk moved into the practical world.</p>

<p>Here, I will try to center focus on the events leading up to Smalltalk-72 and its transition to its modern form as Smalltalk-76. Most of the ideas occurred here, and many of the earliest stages of OOP are poorly documented in references almost impossible to find.</p>

<p>This history is too long, but I was amazed at how many people and systems that had an influence appear only as shadows or not at all. I am sorry not to be able to say more about Bob Balzer, Bob Barton, Danny Bobrow, Steve Carr, Wes Clark, Barbara Deutsch, Peter Deutsch, Bill Duvall, Bob Flegal, Laura Gould, Bruce Horn, Butler Lampson, Dave Liddle, William Newman, Bill Paxton, Trygve Reenskaug, Dave Robson, Doug Ross, Paul Rovner, Bob Sproull, Dan Swinehart, Bert Sutherland, Bob Taylor, Warren Teitelman, Bonnie Tennenbaum, Chuck Thacker, and John Warnock. Worse, I have omitted to mention many systems whose design I detested, but that generated considerable useful ideas and attitudes in reaction. In other words &#8220;histories&#8221; should not be believed very seriously but considered as &#8220;FEEBLE GESTURES OFF&#8221; done long after the actors have departed the stage.</p>

<p>Thanks to the numerous reviewers for enduring the many drafts they had to comment on. Special thanks to Mike Mahoney for helping so gently that I heeded his suggestions and so well that they greatly improved this essay&#8211;and to Jean Sammet, an old old friend, who quite literally frightened me into finishing it&#8211;I did not want to find out what would happen if I were late. Sherri McLoughlin and Kim Rose were of great help in getting all the materials together.</p>

<h2 id='i_196066early_oop_and_other_formative_ideas_of_the_sixties'>I. 1960-66&#8211;Early OOP and other formative ideas of the sixties</h2>

<p>Though OOP came from many motivations, two were central. The large scale one was to find a better module scheme for complex systems involving hiding of details, and the small scale one was to find a more flexible version of assignment, and then to try to eliminate it altogether. As with most new ideas, it originally happened in isolated fits and starts.</p>

<p>New ideas go through stages of acceptance, both from within and without. From within, the sequence moves from &#8220;barely seeing&#8221; a pattern several times, then noting it but not perceiving its &#8220;cosmic&#8221; significance, then using it operationally in several areas, then comes a &#8220;grand rotation&#8221; in which the pattern becomes the center of a new way of thinking, and finally, it turns into the same kind of inflexible religion that it originally broke away from. From without, as Schopenhauer noted, the new idea is first denounced as the work of the insane, in a few years it is considered obvious and mundane, and finally the original denouncers will claim to have invented it.</p>

<p>True to the stages, I &#8220;barely saw&#8221; the idea several times ca. 1961 while a programmer in the Air <img alt='b220 file format' src='figures/b220.png' /> Force. The first was on the Burroughs 220 in the form of a style for transporting files from one Air Training Command installation to another. There were no standard operating systems or file formats back then, so some (to this day unknown) designer decided to finesse the problem by taking each file and dividing it into three parts. The third part was all of the actual data records of arbitrary size and format. The second part contained the B220 procedures that knew how to get at records and fields to copy and update the third part. And the first part was an array or relative pointers into entry points of the procedures in the second part (the initial pointers were in a standard order representing standard meanings). Needless to say, this was a great idea, and was used in many subsequent systems until the enforced use of COBOL drove it out of existence.</p>

<p>The second barely-seeing of the idea came just a little later when ATC decided to replace the 220 with a B5000. I didn&#8217;t have the perspective to really appreciate it at the time, but I did take note of its segmented storage system, its efficiency of HLL compilation and byte-coded execution, its automatic mechanisms for subroutine calling and multiprocess switching, its pure code for sharing, its protection mechanisms, etc. And, I saw that the access to its Program Reference Table corresponded to the 220 file system scheme of providing a procedural interface to a module. However, my big hit from this machine at this time was not the OOP idea, but some insights into HLL translation and evaluation. (Barton, 1961, Burroughs, 1961)</p>

<p>After the Air Force, I worked my way through the rest of college by programming mostly retrieval <img alt='Moores Law graph' src='figures/mooreslaw.png' /> systems for large collections of weather data for the National Center for Atmospheric Research. I got interested in simulation in general&#8211;particularly of one machine by another&#8211;but aside from doing a one-dimensional version of a bit-field block transfer (bitblt) on a CDC 6600 to simulate word sizes of various machines, most of my attention was distracted by school, or I should say the theatre at school. While in Chippewa Falls helping to debug the 6600, I read an article by Gordon Moore which predicted that integrated silicon on chips was going to exponentially improve in density and cost over many years (Moore 65). At the time in 1965, standing next to the room-sized freon-cooled 10 MIP 6600, his astounding predictions had little projection into my horizons.</p>

<h3 id='sketchpad_and_simula'>Sketchpad and Simula</h3>

<p>Through a series of flukes, I wound up in graduate school at the University of Utah in the Fall of 1966, &#8220;knowing nothing.&#8221; That is to say, I had never heard of ARPA or its projects, or that Utah&#8217;s main goal in this community was to solve the &#8220;hidden line&#8221; problem in 3D graphics, until I actually walked into Dave Evans&#8217; office looking for a job and a desk. On Dave&#8217;s desk was a foot-high stack of brown covered documents, one of which he handed to me: &#8220;Take this and read it.&#8221;</p>

<p>Every newcomer got one. The title was &#8220;Sketchpad: A man-machine graphical communication system&#8221; (Sutherland, 1963). What it could do was quite remarkable, and completely foreign to any use of a computer I had ever encountered. The three big ideas that were easiest to grapple with were: it was the invention of modern interactive computer graphics; things were described by making a &#8220;master drawing&#8221; that could produce &#8220;instance drawings&#8221;; control and dynamics were supplied by &#8220;constraints,&#8221; also in graphical form, that could be applied to the masters to shape an inter-related parts. Its data structures were hard to understand&#8211;the only vaguely familiar construct was the embedding of pointers to procedures and using a process called reverse indexing to jump through them to routines, like the 220 file system (Ross, 1961). It was the first to have clipping and zooming windows&#8211;one &#8220;sketched&#8221; on a virtual sheet about 1/3 mile square!</p>

<p><img alt='Sketchpad' src='figures/sketchpad.png' /></p>

<p>Head whirling, I found my desk. On it was a pile of tapes and listings, and a note: &#8220;This is the Algol for the 1108. It doesn&#8217;t work. Please make it work.&#8221; The latest graduate student gets the latest dirty task.</p>

<p>The documentation was incomprehensible. Supposedly, this was the Case-Western Reserve 1107 Algol&#8211;but it had been doctored to make a language called Simula; the documentation read like Norwegian transliterated into English, which in fact it was. There were uses of words like <em>activity</em> and <em>process</em> that didn&#8217;t seem to coincide with normal English usage.</p>

<p>Finally, another graduate student and I unrolled the program listing 80 feet down the hall and crawled over it yelling discoveries to each other. The weirdest part was the storage allocator, which did not obey a stack discipline as was usual for Algol. A few days later, that provided the clue. What Simula was allocating were structures very much like the instances of Sketchpad. There were descriptions that acted like masters and they could create instances, each of which was an independent entity. What Sketchpad called masters and instances, Simula called activities and processes. Moreover, Simula was a procedural language for controlling Sketchpad-like objects, thus having considerably more flexibility than constraints (though at some cost in elegance) (Nygaard, 1966, Nygaard, 1983).</p>

<p>This was the big hit, and I&#8217;ve not been the same since. I think the reason the hit had such impact was that I had seen the idea enough times in enough different forms that the final recognition was in such general terms to have the quality of an epiphany. My math major had centered on abstract algebras with their few operations generally applying to many structures. My biology major had focused on both cell metabolism and larger scale morphogenesis with its notions of simple mechanisms controlling complex processes and one kind of building block able to differentiate into all needed building blocks. The 220 file system, the B5000, Sketchpad, and finally Simula, all used the same idea for different purposes. Bob Barton, the main designer of the B5000 and a professor at Utah had said in one of his talks a few days earlier: &#8220;The basic principal of recursive design is to make the parts have the same power as the whole.&#8221; For the first time I thought of the whole as the entire computer and wondered why anyone would want to divide it up into weaker things called data structures and procedures. Why not divide it up into little computers, as time sharing was starting to? But not in dozens. Why not thousands of them, each simulating a useful structure?</p>

<p>I recalled the monads of Leibniz, the &#8220;dividing nature at its joints&#8221; discourse of Plato, and other attempts to parse complexity. Of course, philosophy is about opinion and engineering is about deeds, with science the happy medium somewhere in between. It is not too much of an exaggeration to say that most of my ideas from then on took their roots from Simula&#8211;but not as an attempt to improve it. It was the promise of an entirely new way to structure computations that took my fancy. As it turned out, it would take quite a few years to understand how to use the insights and to devise efficient mechanisms to execute them.</p>

<h2 id='ii_196769the_flex_machine_a_first_attempt_at_an_oopbased_personal_computer'>II. 1967-69&#8211;The FLEX Machine, a first attempt at an OOP-based personal computer</h2>

<p><img alt='Wes Clark and the LINC, ca 1962' src='figures/linc.png' /></p>

<p>Dave Evans was not a great believer in graduate school as an institution. As with many of the ARPA &#8220;contractors&#8221; he wanted his students to be doing &#8220;real things&#8221;; they should move through graduate school as quickly as possible; and their theses should advance the state of the art. Dave would often get consulting jobs for his students, and in early 1967, he introduced me to Ed Cheadle, a friendly hardware genius at a local aerospace company who was working on a &#8220;little machine.&#8221; It was not the first personal computer&#8211;that was the LINC of Wes Clark&#8211;but Ed wanted it for noncomputer professionals, in particular, he wanted to program it in a higher level language, like BASIC. I said; &#8220;What about JOSS? It&#8217;s nicer.&#8221; He said: &#8220;Sure, whatever you think,&#8221; and that was the start of a very pleasant collaboration we called the FLEX machine. As we got deeper into the design, we realized that we wanted to dynamically <em>simulate</em> and <em>extend,</em> neither of which JOSS (or any existing language that I knew of) was particularly good at. The machine was too small for Simula, so that was out. The beauty of JOSS was the extreme attention of its design to the end-user&#8211;in this respect, it has not been surpassed (Joss 1964, Joss 1978). JOSS was too slow for serious computing (but cf. Lampson 65), did not have real procedures, variable scope, and so forth. A language that looked a little like JOSS but had considerably more potential power was Wirth&#8217;s EULER (Wirth 1966). This was a generalization of Algol along lines first set forth by van Wijngaarden (van Wijngaarden 1963) in which types were discarded, different features consolidated, procedures were made into first class objects, and so forth. Actually kind of LISPlike, but without the deeper insights of LISP.</p>

<p>But EULER was enough of &#8220;an almost new thing&#8221; to suggest that the same techniques be applied to simplify Simula. The EULER compiler was a part of its formal definition and made a simple conversion into 85000-like byte-codes. This was appealing because it s suggested that Ed&#8217;s little machine could run byte-codes emulated in the longish slow microcode that was then possible. The EULER compiler however, was tortuously rendered in an &#8220;extended precedence&#8221; grammar that actually required concessions in the language syntax (e.g. &#8221;,&#8221; could only be used in one role because the precedence scheme had no state space). I initially adopted a bottom-up Floyd-Evans parser (adapted from Jerry Feldman&#8217;s original compiler-compiler - Feldman 1977) and later went to various top-down schemes, several of them related to Shorre&#8217;s META II (Shorre 1963) that eventually put the translater in the name space of the language.</p>

<p>The semantics of what was now called the FLEX language needed to be influenced more by Simula than by Algol or EULER. But it was not completely clear how. Nor was it clear how the users should interact with the system. Ed had a display (for graphing, etc.) even on his first machine, and the LINC had a &#8220;glass teletype,&#8221; but a Sketchpad-like system seemed far beyond the scope that we could accomplish with the maximum of 16k 16-bit words that our cost budget allowed.</p>

<h3 id='doug_engelbart_and_nls'>Doug Engelbart and NLS</h3>

<p><img alt='four pictures' src='figures/nls.png' /></p>

<p>This was in early 1967, and while we were pondering the FLEX machine, Utah was visited by Doug Engelbart. A prophet of Biblical dimensions, he was very much one of the fathers of what on the FLEX machine I had started to call &#8220;personal computing.&#8221; He actually traveled with his own 16mm projector with a remote control for starting and stopping it to show what was going on (people were not used to seeing and following cursors back then). His notion on the ARPA dream was that the destiny of oNLine Systems (NLS) was the &#8220;augmentation of human intellect&#8221; via an interactive vehicle navigating through &#8220;thought vectors in concept space.&#8221; What his system could do then&#8211;even by today&#8217;s standards&#8211;was incredible. Not just hypertext, but graphics, multiple panes, efficient navigation and command input, interactive collaborative work, etc. An entire conceptual world and world view (Engelbart 68). The impact of this vision was to produce in the minds of those who were &#8220;eager to be augmented&#8221; a compelling metaphor of what interactive computing should be like, and I immediately adopted many of the ideas for the FLEX machine.</p>

<p>In the midst of the ARPA context of human-computer symbiosis and in the presence of Ed&#8217;s &#8220;little machine&#8221;, Gordon Moore&#8217;s &#8220;Law&#8221; again came to mind, this time with great impact. For the first time I made the leap of putting the room-sized interactive TX-2 or even a 10 MIP 6600 on a desk. I was almost frightened by the implications; computing as we knew it couldn&#8217;t survive&#8211;the actual meaning of the word changed&#8211;it must have been the same kind of disorientation people had after reading Copernicus and first looked up from a different Earth to a different Heaven.</p>

<p>Instead of at most a few thousand <em>institutional</em> mainframes in the world&#8211;even today in 1992 it is estimated that there are only 4000 IBM mainframes in the entire world&#8211;and at most a few thousand users trained for each application, there would be millions of <em>personal</em> machines and users, mostly outside of direct institutional control. Where would the applications and training come from? Why should we expect an applications programmer to anticipate the specific needs of a particular one of the millions of potential users? An <em>extensional</em> system seemed to be called for in which the end-users would do most of the tailoring (and even some of the direct construction) of their tools. ARPA had already figured this out in the context of their early successes in time-sharing. Their larger metaphor of human-computer symbiosis helped the community avoid making a religion of their subgoals and kept them focused on the abstract holy grail of &#8220;augmentation.&#8221;</p>

<p>One of the interesting features of NLS was that its user interface was parametric and could be supplied by the end user in the form of a &#8220;grammar of interaction&#8221; given in their compiler-compiler TreeMeta. This was similar to William Newman&#8217;s early &#8220;Reaction Handler&#8221; (Newman 66) work in specifying interfaces by having the end-user or developer construct through tablet and stylus an iconic regular expression grammar with action procedures at the states (NLS allowed embeddings via its context free rules). This was attractive in many ways, particularly William&#8217;s scheme, but to me there was a monstrous bug in this approach. Namely, these grammars forced the user to be in a system state which required getting out of before any new kind of interaction could be done. In hierarchical menus or &#8220;screens&#8221; one would have to backtrack to a master state in order to go somewhere else. What seemed to be required were states in which there was a transition arrow to every other state&#8211;not a fruitful concept in formal grammar theory. In other words, a much &#8220;flatter&#8221; interface seemed called for&#8211;but could such a thing be made interesting and rich enough to be useful?</p>

<p>Again, the scope of the FLEX machine was too small for a miniNLS, and we were forced to find alternate designs that would incorporate some of the power of the new ideas, and in some cases to improve them. I decided that Sketchpad&#8217;s notion of a general window that viewed a larger virtual world was a better idea than restricted horizontal panes and with Ed came up with a clipping algorithm very similar to that under development at the same time by Sutherland and his students at Harvard for the 3D &#8220;virtual reality&#8221; helmet project (Sutherland 1968).</p>

<p>Object references were handled on the FLEX machine as a generalization of B5000 descriptors. Instead of a few formats for referencing numbers, arrays, and procedures, a FLEX descriptor contained two pointers: the first to the &#8220;master&#8221; of the object, and the second to the object instances (later we realized that we should put the master pointer in the instance to save space). A different method was taken for handling generalized assignment. The B5000 used l-values and r-values (Strachey) which worked for some cases but couldn&#8217;t handle more complex objects. For example: <code>a[55] := 0</code>, if <code>a</code> was a sparse array whose default element was 0 would still generate an element in the array because := is an &#8220;operator&#8221; and <code>a[55]</code> is dereferenced into an l-value before anyone gets to see that the r-value is the default element, regardless of whether <code>a</code> is an array or a procedure fronting for an array. What is needed is something like: <code>a(55, &#39;:=&#39;, 0),</code> which <em>can</em> look at all relevant operands before any store is made. In other words, := is not an operator, but a kind of index that can select a behavior from a complex object. It took me a remarkably long time to see this, partly I think because one has to invert the traditional notion of operators and functions, etc., to see that objects need to privately own all of their behaviors: <em>that objects are a kind of mapping whose values are its behaviors</em>. A book on logic by Carnap (Ca) helped by showing that &#8220;intensional&#8221; definitions covered the same territory as the more traditional extensional technique and were often more intuitive and convenient.</p>

<p><img alt='Flex machine diagrams' src='figures/flex.png' /></p>

<p>As in Simula, a coroutining control structure (Conway, 1963) was used as a way to suspend and resume objects. Persistent objects like files and documents were treated as suspended processes and were organized according to their Algol-like static variable scopes. These were shown on the screen and could be opened by pointing at them. Coroutining was also used as a control structure for looping. A single operator <strong>while</strong> was used to test the generators which returned <strong>false</strong> when unable to furnish a new value. Booleans were used to link multiple generators. So a &#8220;for-type&#8221; loop would be written as:</p>

<pre><code>while i &lt;= 1 to 30 by 2 ^ j &lt;= 2 to k by 3 do j&lt;-j * i;</code></pre>

<p>where the <strong>&#8230; to &#8230; by &#8230;</strong> was a kind of coroutine object. Many of these ideas were reimplemented in a stronger style in Smalltalk later on.</p>

<p><img alt='FLEX when statement Ka 69' src='figures/flexstatement.png' /></p>

<p>Another control structure of interest in FLEX was a kind of event-driven &#8220;soft interrupt&#8221; called <strong>when</strong>. Its boolean expression was compiled into a &#8220;tournement sort&#8221; tree that cached all possible intermediate results. The relevant variables were threaded through all of the sorting trees in all of the <strong>when</strong>s so that any change only had to compute through the necessary parts of the booleans. The efficiency was very high and was similar to the techniques now used for spreadsheets. This was an embarrassment of riches with difficulties often encountered in event-driven systems. Namely, it was a complex task to control the <em>context</em> of just when the <strong>when</strong>s should be sensitive. Part of the boolean expression had to be used to check the contexts, where I felt that somehow the structure of the program should be able to set and unset the event drivers. This turned out to beyond the scope of the FLEX system and needed to wait for a better architecture.</p>

<p>Still, quite a few of the original FLEX ideas in their proto-object form did turn out to be small enough to be feasible on the machine. I was writing the first compiler when something unusual happened: the Utah graduate students got invited to the ARPA contractors meeting held that year at Alta, Utah. Towards the end of the three days, Bob Taylor, who had succeeded Ivan Sutherland as head of ARPA-IPTO, asked the graduate students (sitting in a ring around the outside of the 20 or so contractors) if they had any comments. John Warnock raised his hand and pointed out that since the ARPA grad students would all soon be colleagues (and since we did all the real work anyway), ARPA should have a contractors-type meeting each year for the grad students. Taylor thought this was a great idea and set it up for the next summer.</p>

<p>Another ski-lodge meeting happened in Park City later that spring. The general topic was education and it was the first time I heard Marvin Minsky speak. He put forth a terrific diatribe against traditional education methods, and from him I heard the ideas of Piaget and Papert for the first time. Marvin&#8217;s talk was about how we think about complex situations and why schools are really bad places to learn these skills. He didn&#8217;t have to make any claims about computers+kids to make his point. It was clear that education and learning had to be rethought in the light of 20th century cognitive psychology and how good thinkers really think. Computing enters as a new representation system with new and useful metaphors for dealing with complexity, especially of systems (Minsky 70).</p>

<p><img alt='The First Plasma Panel' src='figures/plasma.png' /></p>

<p>For the summer 1968 ARPA grad students meeting at Allerton House in Illinois, I boiled all the mechanisms in the FLEX machine down into one 2&#8217;x3&#8217; chart. This included all the &#8220;object structures&#8221;, the compiler, the byte-code interpreter, i/o handlers, and a simple display editor for text and graphics. The grad students were a distinguished group that did indeed become colleagues in subsequent years. My FLEX machine talk was a success, but the big whammy for me came during a tour to U of Illinois where I saw a 1&#8221; square lump of glass and neon gas in which individual spots would light up on command&#8211;it was the first flat-panel display. I spent the rest of the conference calculating just when the silicon of the FLEX machine could be put on the back of the display. According to Gordon Moore&#8217;s &#8220;Law&#8221;, the answer seemed to be sometime in the late seventies or early eighties. A long time off&#8211;it seemed too long to worry much about it then.</p>

<p><img alt='Grail, Seymour Papert and LOGO Turtle, The Dynabook Model' src='figures/dynabookmodel.png' /></p>

<p>But later that year at RAND I saw a truly beautiful system. This was GRAIL, the graphical followon to JOSS. The first tablet (the famous RAND tablet) was invented by Tom Ellis (Davis 1964) in order to capture human gestures, and Gave Groner wrote a program to efficiently recognize and respond to them (Groner 1966). Through everything was fastened with bubble gum and the system crashed often, I have never forgotten my first interactions with this system. It was direct manipulation, it was analogical, it was modeless, it was beautiful. I realized that the FLEX interface was all wrong, but how could something like GRAIL be stuffed into such a tiny machine since it required <em>all</em> of a stand-alone 360/44 to run in?</p>

<p>A month later, I finally visited Seymour Papert, Wally Feurzig, Cynthia Solomon and some of the other original researchers who had built LOGO and were using it with children in the Lexington schools. Here were children doing real programming with a specially designed language and environment. As with Simula leading to OOP, this encounter finally hit me with what the destiny of personal computing <em>really</em> was going to be. Not a personal dynamic <em>vehicle,</em> as in Engelbart&#8217;s metaphor opposed to the IBM &#8220;railroads&#8221;, but something much more profound: a personal dynamic <em>medium.</em> With a vehicle one could wait until high school and give &#8220;drivers ed&#8221;, but if it was a medium, it had to extend into the world of childhood.</p>

<p>Now the collision of the FLEX machine, the flat-screen display, GRAIL, Barton&#8217;s &#8220;communications&#8221; talk, McLuhan, and Papert&#8217;s work with children all came together to form an image of what a personal computer really should be. I remembered Aldus Manutius who 40 years after the printing press put the book into its modern dimensions by making it fit into saddlebags. It had to be no larger than a notebook, and needed an interface as friendly as JOSS&#8217;, GRAIL&#8217;s, and LOGO&#8217;s, but with the reach of Simula and FLEX. A clear romantic vision has a marvelous ability to focus thought and will. Now it was easy to know what to do next. I built a cardboard model of it to see what if would look and feel like, and poured in lead pellets to see how light it would have to be (less than two pounds). I put a keyboard on it as well as a stylus because, even if hand printing and writing were recognized perfectly (and there was no reason to expect that it would be), there still needed to be a balance between the low speed tactile degrees of freedom offered by the stylus and the more limited but faster keyboard. Since ARPA was starting to experiment with packet radio, I expected that the Dynabook when it arrived a decade or so hence, would have a wireless networking system.</p>

<p>Early next year (1969) there was a conference on Extensible Languages in which almost every famous name in the field attended. The debate was great and weighty&#8211;it was a religious war of unimplemented poorly though out ideas. As Alan Perlis, one of the great men in Computer Science, put it with characteristic wit:</p>

<blockquote>
<p>It has been such a long time since I have seen so many familiar faces shouting among so many familiar ideas. Discover of something new in programming languages, like any discovery, has somewhat the same sequence of emotions as falling in love. A sharp elation followed by euphoria, a feeling of uniqueness, and ultimately the wandering eye (the urge to generalize) (ACM 69).</p>
</blockquote>

<p>But it was all talk&#8211;no one had <em>done</em> anything yet. In the midst of all this, Ned Irons got up and presented IMP, a system that had already been working for several years that was more elegant than most of the nonworking proposals. The basic idea of IMP was that you could use any phrase in the grammar as a procedure heading and write a semantic definition in terms of the language as extended so far (Irons 1970).</p>

<p>I had already made the first version of the FLEX machine syntax driven, but where the meaning of a phrase was defined in the more usual way as the kind of code that was emitted. This separated the compiler-extensor part of the system from the end-user. In Irons&#8217; approach, <em>every</em> procedure in the system defined its own syntax in a natural and useful manner. I incorporated these ideas into the second versions of the FLEX machine and started to experiment with the idea of a direct interpreter rather than a syntax directed compiler. Somewhere in all of this, I realized that the bridge to an object-based system could be in terms of each object as a syntax directed interpreter of messages sent to it. In one fell swoop this would unify object-oriented semantics with the ideal of a completely extensible language. The mental image was one of separate computers sending requests to other computers that had to be accepted and understood by the receivers before anything could happen. In today&#8217;s terms every object would be a <em>server</em> offering <em>services</em> whose deployment and discretion depended entirely on the server&#8217;s notion of relationship with the servee. As Liebniz said: &#8220;To get everything out of nothing, you only need to find one principle.&#8221; This was not well thought out enough to do the FLEX machine any good, but formed a good point of departure for my thesis (Kay 69), which as Ivan Sutherland liked to say was &#8220;anything you can get three people to sign.&#8221;</p>

<p>After three people signed it (Ivan was one of them), I went to the Stanford AI project and spent much more time thinking about notebook KiddyKomputers than AI. But there were two AI designs that were very intriguing. The first was Carl Hewitt&#8217;s PLANNER, a programmable logic system that formed the deductive basis of Winograd&#8217;s SHRDLU (Sussman 69, Hewitt 69) I designed several languages based on a combination of the pattern matching schemes of FLEX and PLANNER (Kay 70). The second design was Pat Winston&#8217;s concept formation system, a scheme for building semantic networks and comparing them to form analogies and learning processes (Winston 70). It was kind of &#8220;object-oriented&#8221;. One of its many good ideas was that the arcs of each net which served as attributes in AOV triples should themselves be modeled as nets. Thus, for example a first order arc called LEFT-OF could be asked a higher order question such as &#8220;What is your converse?&#8221; and its net could answer: RIGHT-OF. This point of view later formed the basis for Minsky&#8217;s frame systems (Minsky 75). A few years later I wished I had paid more attention to this idea.</p>

<p>That fall, I heard a wonderful talk by Butler Lampson about CAL-TSS, a capability-based operating system that seemed very &#8220;object-oriented&#8221; (Lampson 69). Unforgeable pointers (ala B5000) were extended by bit-masks that restricted access to the object&#8217;s internal operations. This confirmed my &#8220;objects as server&#8221; metaphor. There was also a very nice approach to exception handling which reminded me of the way failure was often handled in pattern matching systems. The only problem&#8211; which the CAL designers did not see as a problem at all&#8211;was that only certain (usually large and slow) things were &#8220;objects&#8221;. Fast things and small things, etc., weren&#8217;t. This needed to be fixed.</p>

<p>The biggest hit for me while at SAIL in late &#8216;69 was to <em>really understand</em> LISP. Of course, every student knew about <em>car, cdr</em>, and <em>cons</em>, but Utah was impoverished in that no one there used LISP and hence, no one had penetrated the mysteries of <em>eval</em> and <em>apply</em>. I could hardly believe how beautiful and wonderful the <em>idea</em> of LISP was (McCarthy 1960). I say it this way because LISP had not only been around enough to get some honest barnacles, but worse, there were deep flaws in its logical foundations. By this, I mean that the pure language was supposed to be based on functions, but its most important components&#8211;such as lambda expressions, quotes, and conds&#8211;were not functions at all, and instead were called special forms. Landin and others had been able to get quotes and conds in terms of lambda by tricks that were variously clever and useful, but the flaw remained in the jewel. In the practical language things were better. There were not just EXPRs (which evaluated their arguments), but FEXPRs (which did not). My next question was, why on earth call it a functional language? Why not just base everything on FEXPRs and force evaluation on the receiving side when needed? I could never get a good answer, but the question was very helpful when it came time to invent Smalltalk, because this started a line of thought that said &#8220;take the hardest and most profound thing you need to do, make it great, an then build every easier thing out of it&#8221;. That was the promise of LISP and the lure of lambda&#8211;needed was a better &#8220;hardest and most profound&#8221; thing. Objects should be it.</p>

<h2 id='iii_197072xerox_parc_the_kiddikomp_minicom_and_smalltalk71'>III. 1970-72&#8211;Xerox PARC: The KiddiKomp, miniCOM, and Smalltalk-71</h2>

<p>In July 1970, Xerox, at the urging of its chief scientist Jack Goldman, decided to set up a long range research center in Palo Alto, California. In September, George Pake, the former chancellor at Washington University where Wes Clark&#8217;s ARPA project was sited, hired Bob Taylor (who had left the ARPA office and was taking a sabbatical year at Utah) to start a &#8220;Computer Science Laboratory.&#8221; Bob visited Palo Alto and we stayed up all night talking about it. The Mansfield Amendment was threatening to blindly muzzle the most enlightened ARPA funding in favor of directly military research, and this new opportunity looked like a promising alternative. But work for a company? He wanted me to consult and I asked for a direction. He said: follow your instincts. I immediately started working up a new version of the KiddiKomp that could be made in enough quantity to do experiments leading to the user interface design for the eventual notebook. Bob Barton liked to say that &#8220;good ideas don&#8217;t often scale.&#8221; He was certainly right when applied to the FLEX machine. The B5000 just didn&#8217;t directly scale down into a tiny machine. Only the byte-codes did, and even these needed modification. I decided to take another look at Wes Clark&#8217;s LINC, and was ready to appreciate it much more this time (Clark 1965).</p>

<p><img alt='KiddiKomp' src='figures/kiddikomp.png' /></p>

<p>I still liked pattern-directed approaches and OOP so I came up with a language design called &#8220;Simulation LOGO&#8221; or SLOGO for short (I had a feeling the first versions might run nice and slow). This was to be built into a SONY &#8220;tummy trinitron&#8221; and would use a coarse bit-map display and the FLEX machine rubber tablet as a pointing device.</p>

<p>Another beautiful system that I had come across was Peter Deutsch&#8217;s PDP-1 LISP (implemented when he was only 15) (Deutsch 1966). It used only 2K (18-bit words) of code and could run quite well in a 4K machine (it was its own operating system and interface). It seemed that even more could be done if the system were byte-coded, run by an architecture that was hospitable to dynamic systems, and stuck into the ever larger ROMs that were becoming available. One of the basic insights I had gotten from Seymour was that you didn&#8217;t have to do a lot to make a computer an &#8220;object for thought&#8221; for children, but what you did had to be done well and be able to apply deeply.</p>

<p>Right after New Years 1971, Bob Taylor scored an enormous coup by attracting most of the struggling Berkeley Computer Corp to PARC. This group included Butler Lampson, Check Thacker, Peter Deutsch, Jim Mitchell, Dick Shoup, Willie Sue Haugeland, and Ed Fiala. Jim Mitchell urged the group to hire Ed McCreight from CM and he arrived soon after. Gary Starkweather was there already, having been thrown out of the Xerox Rochester Labs for wanting to build a laser printer (which was against the local religion). Not long after, many of Doug Englebart&#8217;s people joined up&#8211;part of the reason was that they want to reimplement NLS as a distributed network system, and Doug wanted to stay with time-sharing. The group included Bill English (the co-inventor of the mouse), Jeff Rulifson, and Bill Paxton.</p>

<p>Almost immediately we got into trouble with Xerox when the group decided that the new lab needed a PDP-10 for continuity with the ARPA community. Xerox (which had bought SDS essentially sight unseen a few years before) was horrified at the idea of their main competitor&#8217;s computer being used in the lab. They balked. The newly formed PARC group had a meeting in which it was decided that it would take about three years to do a good operating system for the XDS SIGMA-7 but that we could <em>build</em> &#8220;our own PDP-10&#8221; in a year. My reaction was &#8220;Holy cow!&#8221; In fact, they pulled it it off with considerable panache. MAXC was actually a microcoded emulation of the PDP-10 that used for the first time the new integrated chip memories (1K bits!) instead of core memory. Having practical in house experience with both of these new technologies was critical for the more radical systems to come.</p>

<p>One little incident of LISP beauty happened when Allen Newell visited PARC with his theory of hierarchical thinking and was challenged to prove it. He was given a programming problem to solve while the protocol was collected. The problem was: given a list of items, produce a list consisting of all of the odd indexed items followed by all of the even indexed items. Newell&#8217;s internal programming language resemble IPL-V in which pointers are manipulated explicitly, and he got into quite a struggle to do the program. In 2 seconds I wrote down:</p>

<pre><code>oddsEvens(x) = append(odds(x), evens(x))</code></pre>

<p>the statement of the problem in Landin&#8217;s LISP syntax&#8211;and also the first part of the solution. Then a few seconds later:</p>

<pre><code>where odds(x) = if null(x) ∨ null(tl(x)) then x
                   else hd(x) &amp; odds(ttl(x))
     evens(x) = if null(x) ∨ null(tl(x)) then nil
                   else odds(tl(x))</code></pre>

<p>This characteristic of writing down many solutions in declarative form and have them also be the programs is part of the appeal and beauty of this kind of language. Watching a famous guy much smarter than I struggle for more than 30 minutes to not quite solve the problem his way (there was a bug) made quite an impression. It brought home to me once again that &#8220;point of view is worth 80 IQ points.&#8221; I wasn&#8217;t smarter but I had a much better internal thinking tool to amplify my abilities. This incident and others like it made paramount that any tool for children should have great thinking patterns <em>and</em> deep beauty &#8220;built-in.&#8221;</p>

<p><img alt='Pendery Paper Display Transducer Design' src='figures/penderypaperdisplay.png' /></p>

<p>Right around this time we were involved in another conflict with Xerox management, in particular with Don Pendery the head &#8220;planner&#8221;. He really didn&#8217;t understand what we were talking about and instead was interested in &#8220;trends&#8221; and &#8220;what was the future going to be like&#8221; and how could Xerox &#8220;defend against it.&#8221; I got so upset I said to him, &#8220;Look. <em>The best way to predict the future is to invent it.</em> Don&#8217;t worry about what all those other people might do, this is the century in which almost any clear vision can be made!&#8221; He remained unconvinced, and that led to the famous &#8220;Pendery Papers for PARC Planning Purposes,&#8221; a collection of essays on various aspects of the future. Mine proposed a version of the notebook as a &#8220;Display Transducer&#8221;, and Jim Mitchell&#8217;s was entitled &#8220;NLS on a Minicomputer.&#8221;</p>

<p>Bill English took me under his wing and helped me start my group as I had always been a lone wolf and had no idea how to do it. One of his suggestions was that I should make a budget. I&#8217;m afraid that I really did ask Bill, &#8220;What&#8217;s a budget?&#8221; I remembered at Utah, in pre-Mansfield Amendment days, Dave Evans saying to me as he went off on a trip to ARPA, &#8220;We&#8217;re almost out of money. Got to go get some more.&#8221; That seemed about right to me. They give you some money. You spend it to find out what to do next. You run out. They give you some more. And so on. PARC never quite made it to that idyllic standard, but for the first half decade it came close. I needed a group because I had finally realized that I did not have all of the temperaments required to completely finish an idea. I called it the Learning Research Group (LRG) to be as vague as possible about our charter. I only hired people that got stars in their eyes when they heard about the notebook computer idea. I didn&#8217;t like meetings: didn&#8217;t believe brainstorming could substitute for cool sustained thought. When anyone asked me what to do, and I didn&#8217;t have a strong idea, I would point at the notebook model and say, &#8220;Advance that.&#8221; LRG members developed a very close relationship with each other&#8211;as Dan Ingalls was to say later: &#8221;&#8230; the rest has enfolded through the love and energy of the whole Learning Research Group.&#8221; A lot of daytime was spent outside of PARC, playing tennis, bikeriding, drinking beer, eating chinese food, and constantly talking about the Dynabook and its potential to amplify human reach and bring new ways of thinking to a faltering civilization that desperately needed it (that kind of goal was common in California in the aftermath of the sixties).</p>

<p>In the summer of &#8216;71 I refined the KiddiKomp idea into a tighter design called miniCOM. It used a bit-slice approach like the NOVA 1200, had a bit-map display, a pointing device, a choice of &#8220;secondary&#8221; (really tertiary) storages, and a language I now called &#8220;Smalltalk&#8221;&#8211;as in &#8220;programming should be a matter of &#8230;&#8221; and &#8220;children should program in &#8230;&#8221;. The name was also a reaction against the &#8220;IndoEuropean god theory&#8221; where systems were named Zeus, Odin, and Thor, and hardly did anything. I figured that &#8220;Smalltalk&#8221; was so innocuous a label that if it ever did anything nice people would be pleasantly surprised.</p>

<p><img alt='miniCOM' src='figures/minicom.png' /></p>

<pre><code>Smalltalk-71 Programs

to T &#39;and&#39; :y do &#39;y&#39;
to F &#39;and&#39; :y do F

to &#39;factorial&#39; 0 is 1
to &#39;factorial&#39; :n do &#39;n*factorial n-1&#39;

to &#39;fact&#39; :n do &#39;to &#39;fact&#39; n do factorial n. ^ fact n&#39;

to :e &#39;is-member-of&#39; [] do F
to :e &#39;is-member-of&#39; :group
          do&#39;if e = firstof group then T
		          else e is-member-of rest of group&#39;

to &#39;cons&#39; :x :y is self
to &#39;hd&#39; (&#39;cons&#39; :a :b) do &#39;a&#39;
to &#39;hd&#39; (&#39;cons&#39; :a :b) &#39;&lt;-&#39; :c do &#39;a &lt;- c&#39;
to &#39;tl&#39; (&#39;cons&#39; :a :b) do &#39;b&#39;
to &#39;tl&#39; (&#39;cons&#39; :a :b) &#39;&lt;-&#39; :c do &#39;b &lt;- c&#39;

to :robot &#39;pickup&#39; :block
         do &#39;robot clear-top-of block.
		 robot hand move-to block.
		 robot hand lift block 50.
		 to &#39;height-of&#39; block do 50&#39;</code></pre>

<p>This Smalltalk language (today labeled -71) was very influenced by FLEX, PLANNER, LOGO, META II, and my own derivatives from them. It was a kind of parser with object-attachment that executed tokens directly. (I think the awkward quoting conventions come from META). I was less interested in programs as algebraic patterns than I was in a clear scheme that could handle a variety of styles of programming. The patterned front-end allowed simple extension, patterns as &#8220;data&#8221; to be retrieved, a simple way to attach behaviors to objects, and a rudimentary but clear expression of its <em>eval</em> in terms that I thought children could understand after a few years experience with simpler programming. Program storage was sorted into a discrimination net and evaluation was straightforward pattern-matching.</p>

<p>As I mentioned previously, it was annoying that the surface beauty of LISP was marred by some of its key parts having to be introduced as &#8220;special forms&#8221; rather than as its supposed universal building block of functions. The actual beauty of LISP came more from the <em>promise</em> of its metastructures than its actual model. I spent a fair amount of time thinking about how objects could be characterized as universal computers without having to have any exceptions in the central metaphor. What seemed to be needed was complete control over what was passed in a message send; in particular <em>when</em> and in <em>what environment</em> did expressions get evaluated?</p>

<p>An elegant approach was suggested in a CMU thesis of Dave Fisher (Fisher 70) on the syntheses of control structures. ALGOL60 required a separate link for dynamic subroutine linking and for access to static global state. Fisher showed how a generalization of these links could be used to simulate a wide variety of control environments. One of the ways to solve the &#8220;funarg problem&#8221; of LiSP is to associate the proper global state link with expressions and functions that are to be evaluated later so that the free variables referenced are the ones that were actually implied by the static form of the language. The notion of &#8220;lazy evaluation&#8221; is anticipated here as well.</p>

<p>Nowadays this approach would be called <em>reflective design</em>. Putting it together with the FLEX models suggested that all that should be required for &#8220;doing LISP right&#8221; or &#8220;doing OOP right&#8221; would be to handle the mechanics of invocations between modules without having to worry about the details of the modules themselves. The difference between LISP and OOP (or any other system) would then be what the modules could contain. A universal module (object) reference &#8211;ala B5000 and LISP&#8211;and a message holding structure&#8211;which could be virtual if the senders and receivers were sympatico&#8211; that could be used by all would do the job.</p>

<p>If all of the fields of a messenger structure were enumerated according to this view, we would have:</p>

<p>GLOBAL: <em>the environment of the parameter values</em></p>

<p>SENDER: <em>the sender of the message</em></p>

<p>RECEIVER: <em>the receiver of the message</em></p>

<p>REPLY-STYLE: <em>wait, fork, &#8230;?</em></p>

<p>STATUS: <em>progress of the message</em></p>

<p>REPLY: <em>eventual result (if any)</em></p>

<p>OPERATION SELECTOR: <em>relative to the receiver</em></p>

<h1 id='of_parameters'>OF PARAMETERS:</h1>

<p>P1:</p>

<p>&#8230;:</p>

<p>Pn:</p>

<p>This is a generalization of a stack frame, such as used by the B5000, and very similar to what a good intermodule scheme would require in an operating system such as CAL-TSS&#8211;a lot of state for every transaction, but useful to think about.</p>

<p>Much of the pondering during this state of grace (before any workable implementation) had to do with trying to understand what &#8220;beautiful&#8221; might mean with reference to object-oriented design. A subjective definition of a beautiful thing is fairly easy but is not of much help: we think a thing beautiful because it evokes certain emotions. The cliche has it lie &#8220;in the eye of the beholder&#8221; so that it is difficult to think of beauty as other than a relation between subject and object in which the predispositions of the subject are all important.</p>

<p>If there are such a thing as universally appealing forms then we can perhaps look to our shared biological heritage for the predispositions. But, for an object like LISP, it is almost certain that most of the basis of our judgement is learned and has much to do with other related areas that we think are beautiful, such as much of mathematics.</p>

<p>One part of the perceived beauty of mathematics has to do with a wondrous synergy between parsimony, generality, enlightenment, and finesse. For example, the Pythagorean Theorem is expressible in a single line, is true for all of the infinite number of right triangles, is incredibly useful in understanding many other relationships, and can be shown by a few simple but profound steps.</p>

<p>When we turn to the various languages for specifying computations we find many to be general and a few to be parsimonious. For example, we can define universal machine languages in just a few instructions that can specify anything that can be computed. But most of these we would not call beautiful, in part because the amount and kind of code that has to be written to do anything interesting is so contrived and turgid. A simple and small system that can do interesting things also needs a &#8220;high slope&#8221;&#8211;that is a good match between the degree of interestingness and the level of complexity needed to express it.</p>

<p>A fertilized egg that can transform itself into the myriad of specializations needed to make a complex organism has parsimony, generality, enlightenment, and finesse&#8211;in short, beauty, and a beauty much more in line with my own esthetics. I mean by this that Nature is wonderful <em>both</em> at elegance and practicality&#8211;the cell membrane is partly there to allow useful evolutionary kludges to do their necessary work and still be able act as component by presenting a uniform interface to the world.</p>

<p>One of my continual worries at this time was about the size of the bit-map display. Even if a mixed mode was used (between fine-grained generated characters and coarse-grained general bit-map for graphics) it would be hard to get enough information on the screen. It occurred to me (in a shower, my favorite place to think) that FLEXtype windows on a bit-map display could be made to appear as overlapping documents on a desktop. When an overlapped one was refreshed it would appear to come to the top of the stack. At the time, this did not appear as <em>the</em> wonderful solution to the problem but it did have the effect of magnifying the effective area of the display enormously, so I decided to go with it.</p>

<p>To investigate the use of video as a display medium, Bill English and Butler Lampson specified an experimental character generator (built by Roger Bates) for the POLOS (PARC OnLine Office System) terminals. Gary Starkweather had just gotten the first laser printer to work and we ran a coax over to his lab to feed him some text to print. The &#8220;SLOT machine&#8221; (Scanning Laser Output Terminal) was incredible. The only Xerox copier Gary could get to work on went at 1 page a second and could not be slowed down. So Gary just made the laser run at that rate with a resolution of 500 pixels to the inch!</p>

<p>The character generator&#8217;s font memory turned out to be large enough to simulate a bit-map display if one displayed a fixed &#8220;strike&#8221; and wrote into the font memory. Ben Laws built a beautiful font editor and he and I spent several months learning about the peculiarities of the human visual system (it is decidedly non-linear). I was very interested in high-quality text and graphical presentations because I thought it would be easier to get the Dynabook into schools as a &#8220;trojan horse&#8221; by simply replacing school books rather than to try to explain to teachers and school boards what was really great about personal computing.</p>

<p><img alt='The Old Character Generator  early 1972' src='figures/oldcharacter.png' /></p>

<p>Things were generally going well all over the lab until May of 72 when I tried to get resources to build a few miniCOMs. A relatively new executive (&#8221;X&#8221;) did not want to give them to me. I wrote a memo explaining why the system was a good idea (see Appendix II), and then had a meeting to discuss it. &#8220;X&#8221; shot it down completely saying among other things that we had used too many green stamps getting Xerox to fund the time-shared MAXC and this use of resources for personal machines would confuse them. I was shocked. I crawled away back to the experimental character generator and made a plan to get 4 more made and hooked to NOVAs for the initial kid experiments.</p>

<p>I got Steve Purcell, a summer student from Stanford, to build my design for bit-map painting so the kids could sketch as well as display computer graphics. John Shoch built a line drawing and gesture recognition system (based on Ledeen&#8217;s - Newman and Sproull 72) that was integrated with the painting. Bill Duvall of POLOS built a miniNLS that was quite remarkable in its speed and power. The first overlapping windows started to appear. Bob Shur (with Steve Purcell&#8217;s help) built a 2½D animation system. Along with Ben Laws&#8217; font editor, we could give quite a smashing demo of what we intended to build for real over the next few years. I remember giving one of these to a Xerox executive, including doing a portrait of him in the new painting system, and wound it up with a flourish declaring: &#8220;And what&#8217;s really great about this is that it only has a 20% chance of success. We&#8217;re taking risk just like you asked us to!&#8221; He looked me straight in the eye and said, &#8220;Boy, that&#8217;s great, but just make sure it works.&#8221; This was a typical executive notion about risk. He wanted us to be in the &#8220;20%&#8221; one hundred percent of the time.</p>

<p><img alt='The First Painting System  Summer 72' src='figures/firstpainting.png' /></p>

<p>That summer while licking my wounds and getting the demo simulations built and going, Butler Lampson, Peter Deutsch, and I worked out a general scheme for emulated HLL machine languages. I liked the B5000 scheme, but Butler did not want to have to decode bytes, and pointed out that since an 8-bit byte had 256 total possibilities, what we should do is map different meanings onto different parts of the &#8220;instruction space.&#8221; This would give us a &#8220;poor man&#8217;s Huffman code&#8221; that would be both flexible and simple. All subsequent emulators at PARC used this general scheme.</p>

<p>I also took another pass at the language for the kids. Jeff Rulifson was a big fan of Piaget (and semiotics) and we had many discussions about the &#8220;stages&#8221; and what iconic thinking might be about. After reading Piaget and especially Jerome Bruner, I was worried that the directly symbolic approach taken by FLEX, LOGO (and the current Smalltalk) would be difficult for the kids to process since evidence existed that the symbolic stage (or mentality) was just starting to switch on. In fact, all of the educators that I admired (including Montessori, Holt, and Suzuki) all seemed to call for a more figurative, more iconic approach. Rudolph Arnheim (Arnheim 69) had written a classic book about visual thinking, and so had the eminent art critic Gombrich (Gombrich). It really seemed that something better needed to be done here. GRAIL wasn&#8217;t it, because its use of imagery was to portray and edit flowcharts, which seemed like a great step backwards. But Rovner&#8217;s AMBIT-G held considerably more promise (Rovner 68). It was kind of a visual SNOBOL (Farber 63) and the pattern matching ideas looked like they would work for the more PLANNER-like scheme I was using.</p>

<p>Bill English was still encouraging me to do more reasonable appearing things to get higher credibility, like making budgets, writing plans and milestone notes, so I wrote a plan that proposed over the next few years that we would build a real system on the character generators <em>cum</em> NOVAs that would involve OOP, windows, painting, music, animation, and &#8220;iconic programming.&#8221; The latter was deemed to be hard and would be handled by the usual method for hard problems, namely, give them to grad students.</p>

<p><img alt='Children with Dynabooks from A Personal Computer For Children Of All Ages (Ka 72), Iconic Bubble Sort from 1972 LRG Plan Ka 72a' src='figures/childrenwithdynabooks.png' /></p>

<h2 id='iv_197276the_first_real_smalltalk_72_its_birth_applications_and_improvements'>IV. 1972-76&#8211;The first real Smalltalk (-72), its birth, applications, and improvements</h2>

<p>In Sept, within a few weeks of each other, two bets happened that changed most of my plans. First, Butler and Chuck came over and asked: &#8220;Do you have any money?&#8221; I said, &#8220;Yes, about $230K for NOVAs and CGs. Why?&#8221; They said, &#8220;How would you like us to build your little machine for you?&#8221; I said, &#8221;I&#8217;d like it fine. What is it?&#8221; Butler said: &#8220;I want a &#8216;$500 PDP-10&#8217;, Chuck wants a &#8216;10 times faster NOVA&#8217;, and you want a &#8216;kiddicomp&#8217;. What do you need on it?&#8221; I told them most of the results we had gotten from the fonts, painting, resolution, animation, and music studies. I asked where this had come from all of a sudden and Butler told me that they wanted to do it anyway, that Executive &#8220;X&#8221; was away for a few months on a &#8220;task force&#8221; so maybe they could &#8220;Sneak it in&#8221;, and that Chuck had a bet with Bill Vitic that he could do a whole machine in just 3 months. &#8220;Oh,&#8221; I said.</p>

<p>The second bet had even more surprising results. I had expected that the new Smalltalk would be an iconic language and would take at least two years to invent, but fate intervened. One day, in a typical PARC hallway bullsession, Ted Kaehler, Dan Ingalls, and I were standing around talking about programming languages. The subject of power came up and the two of them wondered how large a language one would have to make to get great power. With as much panache as I could muster, I asserted that you could define the &#8220;most powerful language in the world&#8221; in &#8220;a page of code.&#8221; They said, &#8220;Put up or shut up.&#8221;</p>

<p>Ted went back to CMU but Dan was still around egging me on. For the next two weeks I got to PARC every morning at four o&#8217;clock and worked on the problem until eight, when Dan, joined by Henry Fuchs, John Shoch, and Steve Purcell showed up to kibbitz the morning&#8217;s work.</p>

<p>I had originally made the boast because McCarthy&#8217;s self-describing LISP interpreter was written in itself. It was about &#8220;a page&#8221;, and as far as power goes, LISP was the whole nine-yards for functional languages. I was quite sure I could do the same for object-oriented languages <em>plus</em> be able to do a reasonable syntax for the code <em>a la</em> some of the FLEX machine techniques.</p>

<p>It turned out to be more difficult than I had first thought for three reasons. First, I wanted the program to be more like McCarthy&#8217;s second non-recursive interpreter&#8211;the one implemented as a loop that tried to resemble the original 709 implementation of Steve Russell as much as possible. It was more &#8220;real&#8221;. Second, the intertwining of the &#8220;parsing&#8221; with message receipt&#8211;the evaluation of parameters which was handled separately in LISP&#8211;required that my object-oriented interpreter re-enter itself &#8220;sooner&#8221; (in fact, much sooner) than LISP required. And, finally, I was still not clear how <em>send</em> and <em>receive</em> should work with each other.</p>

<p>The first few versions had flaws that were soundly criticized by the group. But by morning 8 or so, a version appeared that seemed to work (see Appendix III for a sketch of how the interpreter was designed). The major differences from the official Smalltalk-72 of a little bit later were that in the first version symbols were byte-coded and the receiving of return of return-values from a send was symmetric&#8211;i.e. receipt could be like parameter binding&#8211;this was particular useful for the return of multiple values. For various reasons, this was abandoned in favor of a more expression-oriented functional return style.</p>

<p>Of course, I had gone to considerable pains to avoid doing any &#8220;real work&#8221; for the bet, but I felt I had proved my point. This had been an interesting holiday from our official &#8220;iconic programming&#8221; pursuits, and I thought that would be the end of it. Much to my surprise, only a few days later, Dan Ingalls showed me the scheme <em>working</em> on the NOVA. He had coded it up (in BASIC!), added a lot of details, such as a token scanner, a list maker, etc., and there it was&#8211;running. As he liked to say: &#8220;You just do it and it&#8217;s done.&#8221;</p>

<p>It evaluated <em>3+4</em> <em>v e r y s l o w l y</em> (it was &#8220;glacial&#8221;, as Butler liked to say) but the answer always came out 7. Well, there was nothing to do but keep going. Dan loved to bootstrap on a system that &#8220;always ran,&#8221; and over the next ten years he made at least 80 major releases of various flavors of Smalltalk.</p>

<p>In November, I presented these ideas and a demonstration of the interpretation scheme to the MIT AI lab. This eventually led to Carl Hewitt&#8217;s more formal &#8220;Actor&#8221; approach (Hewitt 73). In the first Actor paper the resemblance to Smalltalk is at its closest. The paths later diverged, partly because we were much more interested in making things than theorizing, and partly because we had something no one else had: Chuck Thacker&#8217;s Interim Dynabook (later known as the &#8220;ALTO&#8221;).</p>

<p>Just before Chuck started work on the machine I gave a paper to the National Council of Teachers of English (Kay 72c) on the Dynabook and its potential as a learning and thinking amplifier&#8211;the paper was an extensive rotogravure of &#8220;20 things to do with a Dynabook&#8221; (Kay 72c). By the time I got back from Minnesota, Stewart Brand&#8217;s <em>Rolling Stone</em> article about PARC (Brand 1972) and the surrounding hacker community had hit the stands. To our enormous surprise it caused a major furor at Xerox headquarters in Stamford, Connecticut. Though it was a wonderful article that really caught the spirit of the whole culture, Xerox went berserk, forced us to wear badges (over the years many were printed on t-shirts), and severely restricted the kinds of publications that could be made. This was particularly disastrous for LRG, since we were the &#8220;lunatic fringe&#8221; (so-called by the other computer scientists), were planning to go out to the schools, and needed to share our ideas (and programs) with our colleagues such as Seymour Papert and Don Norman.</p>

<p>Executive &#8220;X&#8221; apparently heard some harsh words at Stamford about us, because when he returned around Christmas and found out about the interim Dynabook, he got even more angry and tried to kill it. Butler wound up writing a masterful defense of the machine to hold him off, and he went back to his &#8220;task force.&#8221;</p>

<p><img alt='BILBO, the first interim Dynabook, and Cookie Monster, the first graphics it displayed. April, 1973' src='figures/bilbo.png' /></p>

<p>Check had started his &#8220;bet&#8221; on November 22, 1972. He and two technicians did all of the machine except for the disk interface which was done by Ed McCreight. It had a ~500,000 pixel (606x808) bitmap display, its microcode instruction rate was about 6 MIPS, it had a grand total of 128k, and the entire machine (exclusive of the memory) was rendered in 160 MSI chips distributed on two cards. It was beautiful (Thacker 1972, 1986). One of the wonderful features of the machine was &#8220;zero-over-head&#8221; tasking. It had 16 program counters, one for each task. Condition flags were tied to interesting events (such as &#8220;horizontal retrace pulse&#8221;, and &#8220;disk sector pulse&#8221;, etc.). Lookaside logic scanned the flags while the current instruction was executing and picked the highest priority program counter to fetch from next. The machine never had to wait, and the result was that most hardware functions (particularly those that involved i/o (like feeding the display and handling the disk) could be replaced by microcode. Even the refresh of the MOS dynamic RAM was done by a task. In other words, this was a coroutine architecture. Chuck claimed that he got the idea from a lecture I had given on coroutines a few months before, but I remembered that Wes Clark&#8217;s TX-2 (the Sketchpad machine) had used the idea first, and I probably mentioned that in the talk.</p>

<p>In early April, just a little over three months from the start, the first Interim Dynabook, known as &#8216;Bilbo,&#8217; greeted the world and we had the first bit-map picture on the screen within minutes: the Muppets&#8217; Cookie Monster that I had sketched on our painting system.</p>

<p>Soon Dan had bootstrapped Smalltalk across, and for many months it was the sole software system to run on the Interim dynabook. Appendix I has an &#8220;acknowledgements&#8221; document I wrote from this time that is interesting it its allocation of credits and the various priorities associated with them. My $230K was enough to get 15 of the original projected 30 machines (over the years some 2000 Interim Dynabooks were actually built). True to Schopenhauer&#8217;s observation, Executive &#8220;X&#8221; now decided that the Interim Dynabook was a <em>good</em> idea and he wanted <em>all but two</em> for his lab (I was in the other lab). I had to go to considerable lengths to get our machines back, but finally succeeded.</p>

<p>1. Everything is an object 2. Objects communicate by sending and receiving <em>messages</em> (in terms of objects) 3. Objects have their <em>own memory</em> (in terms of objects) 4. Every object is an instance of a <em>class</em> (which must be an object) 5. The class holds the shared <em>behavior</em> for its instances (in the form of objects in a program list) 6. To eval a program list, control is passed to the first object and the remainder is treated as its message</p>

<p>By this time most of Smalltalk&#8217;s schemes had been sorted out into six main ideas that were in accord with the initial premises in designing the interpreter. The first three principles are what objects &#8220;are about&#8221;&#8211;how they are seen and used from &#8220;the outside.&#8221; These did not require any modification over the years. The last three&#8211;objects from the inside&#8211;were tinkered with in every version of Smalltalk (and in subsequent OOP designs). In this scheme (1 &amp; 4) imply that classes are objects and that they must be instances of themself. (6) implies a LISP-like universal syntax, but with the receiving object as the first item followed by the message. Thus <code>ci &lt;- de</code> (with subscripting rendered as <code>○</code> and multiplication as <code>*</code>) means:</p>

<pre><code>_receiver_
_| message_

_c_
_| ○ i &lt;- d*e_</code></pre>

<p>The c is bound to the receiving object, and <em>all</em> of <code>○ i &lt;- d*e</code> is the message to it. The message is made up of literal token <code>○</code>, an expression to be evaluated in the sender&#8217;s context (in this case i), another literal token <code>&lt;-</code>, followed by an expression to be evaluated in the sender&#8217;s context <code>(d*e)</code>. Since &#8220;LISP&#8221; pairs are made from 2 element objects they can be indexed more simply: <code>c hd</code>, <code>c tl</code>, and <code>c hd &lt;- foo</code>, etc.</p>

<p>&#8220;Simple&#8221; expressions like <code>a+b</code> and <code>3+4</code> seemed more troublesome at first. Did it really make sense to think of them as:</p>

<pre><code>_receiver_
_| message_

_a_
_| + b_

_3_
_| + 4_</code></pre>

<p>It seemed silly if only integers were considered, but there are many other metaphoric readings of &#8221;+&#8221;, such as:</p>

<pre><code>[&quot;kitty&quot; |+ &quot;kat&quot; =&gt; &quot;kittykat&quot; [3 4 5 6 7 8] |+ 4 =    
[7 8 9 10 11 12] &quot;kittykat&quot; [3 4 5 6 7 8] |+ 4 =    
[7 8 9 10 11 12]</code></pre>

<p>This led to a style of finding <em>generic behaviors</em> for message symbols. &#8220;Polymorphism&#8221; is the official term (I believe derived from Strachey), but it is not really apt as its original meaning applied only to functions that could take more than one type of argument. An example class of objects in Smalltalk-72, such as a model of CONS pairs, would look like:</p>

<p><img alt='Model of CONS pairs' src='figures/conspairs.png' /></p>

<p>Since control is passed to the class before any of the rest of the message is considered&#8211;the class can decide <em>not</em> to receive at its discretion&#8211;complete protection is retained. Smalltalk-72 objects are &#8220;shiny&#8221; and impervious to attack. Part of the environment is the binding of the SENDER in the &#8220;messenger object&#8221; (a generalized activation record) which allows the receiver to determine differential privileges (see Appendix II for more details). This looked ahead to the eventual use of Smalltalk as a network OS (See Goldstein &amp; Bobrow 1980), and I don&#8217;t recall it being used very much in Smalltalk-72.</p>

<p>One of the styles retained from Smalltalk-71 was the comingling of function and class ideas. In other works, Smalltalk-72 classes looked like and could be used as functions, but it was easy to produce an instance (a kind of closure) by using the object ISNEW. Thus factorial could be written &#8220;extensionally&#8221; as:</p>

<pre><code>to fact n (^if :n=0 then 1 else n*fact n-1)</code></pre>

<p>or &#8220;intensionally,&#8221; as part of class integer:</p>

<pre><code>(... ○! » (^:n=1) » (1) (n-1)!)</code></pre>

<p>Of course, the whole idea of Smalltalk (and OOP in general) is to define everything <em>intensionally</em>. And this was the direction of movement as we learned how to program in the new style. I never liked this syntax (too many parentheses and nestings) and wanted something flatter and more grammar-like as in Smalltalk-71. To the right is an example syntax from the notes of a talk I gave around then. We will see something more like this a few years later in Dan&#8217;s design for Smalltalk-76. I think something similar happened with LISP&#8211;that the &#8220;reality&#8221; of the straightforward and practical syntax you could program in prevailed against the flights of fancy that never quite got built.</p>

<p>Proposed Smalltalk-72 Syntax</p>

<pre><code>Pair :h :t
    hd &lt;- :h
	hd              » h
	tl &lt;- :t
	tl              » t
	isPair          » true
	print           » &#39;( print. SELF mprint.
	mprint          » h print. if t isNil then &#39;) print
                               else if t isPair then t mprint
                               else &#39;* print. t print. &#39;) print
	length          » 1 + if t isList then t length else 0</code></pre>

<h3 id='development_of_the_smalltalk72_system_and_applications'>Development of the Smalltalk-72 System and Applications</h3>

<p><img alt='One of the first build ALTOs, Early Smalltalk Windows on Interim Dynabook, Turtles' src='figures/firstbuildaltos.png' /></p>

<p>The advent of a real Smalltalk on a real machine started off an explosion of parallel paths that are too difficult to intertwine in strict historical order. Let me first present the general development of the Smalltalk-72 system up to the transition to Smalltalk-76, and then follow that with the several years of work with children that were the primary motivation for the project. The Smalltalk-72 interpreter on the Interim Dynabook was not exactly zippy (&#8220;majestic&#8221; was Butler&#8217;s pronouncement), but was easy to change and quite fast enough for many real-time interactive systems to be built in it.</p>

<p>Overlapping windows were the first project tackled (with Diana Merry) after writing the code to read the keyboard and create a string of text. Diana built an early version of a bit field block transfer (bitblt) for displaying variable pitch fonts and generally writing on the display. The first window versions were done as real 2½D draggable objects that were just a little too slow to be useful. We decided to wait until Steve Purcell got his animation system going to do it right, and opted for the style that is still in use today, which is more like &#8220;2¼D&#8221;. Windows were perhaps the most redesigned and reimplemented class in Smalltalk because we didn&#8217;t quite have enough compute power to just do the continual viewing to &#8220;world coordinates&#8221; and refereshing that my former Utah colleagues were starting to experiment with on the flight simulator projects at Evans &amp; Sutherland. This is a simple, powerful model but it is difficult to do in real-time even in 2½D. The first practical windows in Smalltalk used the GRAIL conventions of sensitive corners for moving, resizing, cloning, and closing. Window scheduling used a simple &#8220;loopless&#8221; control scheme that threaded all of the windows together.</p>

<p>One of the next classes to be implemented on the Interim Dynabook (after the basics of numbers, strings, etc.) was an object-oriented version of the LOGO turtle implemented by Ted. This could make many turtle instances that were used both for drawing and as a kind of value for graphics transformations. Dan created a class of &#8220;commander&#8221; turtles that could control a troop of turtles. Soon the turtles were made so they could be clipped by the windows.</p>

<p>John Shoch built a mouse-driven structured editor for Smalltalk code.</p>

<p><img alt='Findit Retrieval By Example, Retrieved HyperDocument, FM Timbre Editor, OPUS Score Capture' src='figures/findit.png' /></p>

<p>Larry Tesler (then working for POLOS) did not like the modiness and general approach of NLS, and he wanted both show the former NLSers an alternative and to conduct some user studies (almost unheard of in those days) about editing. This led to his programming <em>miniMOUSE</em> in Smalltalk, the first real WYSIWYG galley editor at PARC. It was modeless (almost) and fun to use, not just for us but for the many people he tested it on (I ran the camera for the movies we took and remember their delight and enjoyment). <em>miniMOUSE</em> quickly became an alternate editor for Smalltalk code and some of the best demos we ever gave used it.</p>

<p>One of the &#8220;small program&#8221; projects I tried on an adult class in the Spring of &#8216;74 was a one-page paragraph editor. It turned out to be too complicated, but the example I did to show them was completely modeless (it was in the air) and became the basis for much of the Smalltalk text work over the next few years. Most of the improvements were made by Dan and Diana Merry. Of course, objects mean multi-media documents, you almost get them for free. Early on we realized that in such a document, each component object should handle its own editing chores. Steve Weyer built some of the earliest multi-media documents, whose range was greatly and variously expanded over the years by Bob Flegal, Diana Merry, Larry Tesler, Tim Mott, and Trygve Reenskaug.</p>

<p>Steve Weyer and I devised <em>Findit</em>, a &#8220;retrieval by example&#8221; interface that used the analogy of classes to their instances to form retrieval requests. This was used for many years by the PARC library to control circulation.</p>

<p>The sampling synthesis music I had developed on the NOVA could generate 3 high-quality real-time voices. Bob Shur and Chuck Thacker transferred the scheme to the Interim Dynabook and achieved 12 voices in real-time. The 256 bit generalized input that we had specified for low speed devices (used for the mouse and keyboard) made it easy to connect 154 more to wire up two organ keyboards and a pedal. Effects such as portamento and decay were programmed. Ted Kaehler wrote TWANG, a music capture and editing system, using a tablature notation that we devised to make music clear to children (Kay 1977a). One of the things that was hard to do with sampling was the voltage controlled oscillator (VCO) effects that were popular on the &#8220;Well Tempered Synthesizer.&#8221; A summer later, Steve Saunders, another of our bright summer students, was challenged to find a way to accomplish John Chowning&#8217;s <em>very</em> non-real-time FM synthesis in real-time on the ID. He had to find a completely different way to think of it than &#8220;FM&#8221;, and succeeded brilliantly with 8 real-time voices that were integrated into TWANG (Saunders).</p>

<p><img alt='Shazam iconic user interface, PYGMALION Iconic Programming, Simpula Hospital Simulation' src='figures/shazam.png' /></p>

<p>Chris Jeffers (who was a musician and educator, not a computer scientist) knocked us out with OPUS, the first real-time score capturing system. Unlike most systems today it did not require metronomic playing but instead took a first pass looking for strong and weak beats (the phrasing) to establish a local model of the likely tempo fluctuations and then used curve fitting and extrapolation to make judgements about just where in the measure, and for what time value, a given note had been struck.</p>

<p>The animations on the NOVA ran 3-5 objects at about 2-3 frames per second. Fast enough for the <em>phi</em> phenomenon to work (if double buffering was used), but we wanted &#8220;Disney rates&#8221; of 10-15 frames a second for 10 or more large objects and many more smaller ones. This task was put into the ingenious hands of Steve Purcell. By the fall of &#8216;73 he could demo 80 ping-pong balls and 10 flying horses running at 10 frames per second in 2½D. His next task was to make the demo into a general systems facility from which we could construct animation systems. His CHAOS system started working in May &#8216;74, just in time for summer visitors Ron Baecker, Tom Horseeley, and professional animator Eric Martin to visit and build SHAZAM a marvelously capable and simple animation system based on Ron&#8217;s GENESYS thesis project on the TX-2 in the late sixties (Baecker 69).</p>

<p>The main thesis project during this time was Dave Smith&#8217;s PYGMALION (Smith 75), an essay into iconic programming (no, we hadn&#8217;t quite forgotten). One programmed by showing the system how changes should be made, much as one would illustrate on a blackboard with another programmer. This program became the starting place from which many subsequent &#8220;programming by example&#8221; systems took off.</p>

<p>I should say something about the size of these programs. PYGMALION was the largest program ever written in Smalltalk-72. It was about 20 pages of code&#8211;all that would fit in the interim dynabook ALTO&#8211;and is given in full in Smith&#8217;s thesis. All of the other applications were smaller. For example, the SHAZAM animation system was written and revised several times in the summer of 1974, and finally wound up as a 5-6 page application which included its icon-controlled multiwindowed user interface.</p>

<p>Given its roots in simulation languages, it was easy to write in a few pages, Simpula, a simple version of the SIMULA sequencing set approach to scheduling. By this time we had decided that coroutines could be more cleanly be rendered by scheduling individual methods as separate simulation phases. The generic SIMULA example was a job shop. This could be generalized into many useful forms such as a hospital with departments of resources serving patients (see to the right). The children did not care for hospitals but saw that they could model amusement parks, like Disneyland, their schools, the stores they and their parents shopped in, and so forth. Later this model formed the basis of the Smalltalk Sim-kit, a high-level end-user programming environment (described ahead).</p>

<pre><code>(until Return or Delete do
    (&#39;character &lt;- display &lt;- keyboard.
    character = ret » (Return)
    character = del » (Delete)
    )
then case
    Return: (&#39;deal with this normal exit&#39;)
    Delete: (&#39;handle the abnormal exit&#39;))</code></pre>

<p>Many nice &#8220;computer sciency&#8221; constructs were easy to make in Smalltalk-72. For example, one of the controversies of the day was whether to have gotos or not (we didn&#8217;t), and if not, how could certain very useful control structures&#8211;such as multiple exits from a loop&#8211;be specified? Chuck Zahn at SLAC proposed an <em>event-driven case</em> structure in which a set of events could be defined so that when an event is encountered, the loop will be exited and the event will select a statement in a case block (Zahn 1974, Knuth 1974). Suppose we want to write a simple loop that reads characters from the keyboard and outputs them to a display. We want it to exit normally when the <em>return</em> key is struck and with an error if the <em>delete</em> key is hit. Appendix IV shows how John Shoch defined this control structure.</p>

<h3 id='the_evolution_of_smalltalk72'>The Evolution of Smalltalk-72</h3>

<p>Smalltalk-74 (sometimes known as FastTalk) was a version of Smalltalk-72 incorporating major improvements which included providing a real &#8220;messenger&#8221; object, message dictionaries for classes (a step towards real class objects), Diana Merry&#8217;s bitblt (the now famous 2D graphics operator for bitmap graphics) redesigned by Dan and implemented in microcode, and a better, more general window interface. Dave Robson while a student at UC Irvine had heard of our project and made a pretty good stab at implementing an OOPL. We invited him for a summer and never let him go back&#8211;he was a great help in formulating an official semantics for Smalltalk.</p>

<p>The crowning addition was the OOZE (Object Oriented Zoned Environment) virtual memory system that served Smalltalk-74, and more importantly, Smalltalk-76 (Ing 78, Kae). The ALTO was not very large (128-256K), especially with its page-sized display (64k), and even with small programs, we soon ran out of storage. The 2.4 megabyte model 30 disk drive was faster and larger than a floppy and slower and smaller than today&#8217;s hard drives. It was quite similar to the HP direct contact disk of the FLEX machine on which I had tried a fine-grain version of the B5000 segment swapper. It had not worked as well as I wanted, despite a few good ideas as to how to choose objects when purging. When the gang wanted to adopt this basic scheme, I said: &#8220;But I never got it to work well.&#8221; I remember Ted Kaehler saying, &#8220;Don&#8217;t worry, we&#8217;ll make it work!&#8221;</p>

<p>The basic idea in all of these systems is to be able to gather the most comprehensive possible working set of objects. This is most easily accomplished by swapping individual objects. Now the problem becomes the overhead of purging non-working set objects to make room for the ones that are needed. (Paging sometimes works better for this part because you can get more than one object (OOZE) in each disk touch.) Two ideas help a lot. First, Butler&#8217;s insight in the GENIE OS that it was worthwhile to expend a small percentage of time purging dirty objects to make core as clean as possible (Lampson 1966). Thus crashes tend not to hurt as much and there is always clean storage to fetch pages or objects from the disk into. The other is one from the FLEX system in which I set up a stochastic decision mechanism (based on the class of an object) that determined during a purge whether or not to throw an object out. This had two benefits: important objects tended not to go out, and a mistake would just bring it back in again with the distribution insuring a low probability that the object would be purged again soon.</p>

<p>The other problem that had to be taken care of was object-pointer integrity (and this is where I had failed in the FLEX machine to come up with a good enough solution). What was needed really was a complete <em>transaction,</em> a brand new technique (thought up by Butler?) that ensured recovery regardless of when the system crashed. This was called &#8220;cosmic ray protection&#8221; as the early ALTOS had a way of just crashing once or twice a day for no discernible good reason. This, by the way did not particularly bother anyone as it was fairly easy to come up with <em>undo</em> and <em>replay</em> mechanisms to get around the cosmic rays. For pointer-based systems that had automatic storage management, this was a bit more tricky.</p>

<p>Ted and Dan decided to control storage using a Resident Object Table that was the only place machine addresses for objects would be found. Other useful information was stashed there as well to help LRU aging. Purging was done in background by picking a class, positioning the disk to its instances (all of a particular class were stored together), then running through the ROT to find the dirty ones in storage and stream them out. This was pretty efficient and, true to Butler&#8217;s insight, furnished a good sized pool of clean storage that could be overwritten. The key to the design though (and the implementation of the transaction mechanism) was the checkpointing scheme they came up with. This insured that there was a recoverable image no more than a few seconds old, regardless of when a crash might occur. OOZE swapped objects in just 80kb of working storage and could handle about 65K objects (up to several megabytes worth, more than enough for the entire system, its interface, and its applications).</p>

<h3 id='objectoriented_style'>&#8220;Object-oriented&#8221; Style</h3>

<p>This is probably a good place to comment on the difference between what we thought of as OOP-style and the superficial encapsulation called &#8220;abstract data types&#8221; that was just starting to be investigated in academic circles. Our early &#8220;LISP-pair&#8221; definition is an example of an abstract data type because it preserves the &#8220;field access&#8221; and &#8220;field rebinding&#8221; that is the hallmark of a data structure. Considerable work in the 60s was concerned with generalizing such structures (DSP). The &#8220;official&#8221; computer science world started to regard Simula as a possible vehicle for defining abstract data types (even by one of its inventors (Dahl 1970)), and it formed much of the later backbone of ADA. This led to the ubiquitous stack data-type example in hundreds of papers. To put it mildly, we were quite amazed at this, since to us, what Simula had whispered was something much stronger than simply reimplementing a weak and ad hoc idea. What I got from Simula was that you could now replace bindings and assignment with <em>goals</em>. The last thing you wanted any programmer to do is mess with internal state even if presented figuratively. Instead, the objects should be presented as <em>sites of higher level behaviors more appropriate for use as dynamic components</em>.</p>

<p>Even the way we taught children (cf. ahead) reflected this way of looking at objects. Not too surprisingly this approach has considerable bearing on the ease of programming, the size of the code needed, the integrity of the design, etc. It is unfortunate that much of what is called &#8220;object-oriented programming&#8221; today is simply old style programming with fancier constructs. Many programs are loaded with &#8220;assignment-style&#8221; operations now done by more expensive attached procedures.</p>

<p>Where does the special efficiency of object-oriented design come from? This is a good question given that it can be viewed as a slightly different way to apply procedures to data-structures. Part of the effect comes from a much clearer way to represent a complex system. Here, the constraints are as useful as the generalities. Four techniques used together&#8211;persistent state, polymorphism, instantiation, and methods-as-goals for the object&#8211;account for much of the power. None of these require an &#8220;object-oriented language&#8221; to be employed&#8211;ALGOL 68 can almost be turned to this style&#8211;an OOPL merely focuses the designer&#8217;s mind in a particular fruitful direction. However, doing encapsulation right is a commitment not just to abstraction of state, but to eliminate state oriented metaphors from programming.</p>

<p>Perhaps the most important principle&#8211;again derived from operating system architectures&#8211;is that when you give someone a structure, rarely do you want them to have unlimited privileges with it. Just doing type-matching isn&#8217;t even close to what&#8217;s needed. Nor is it terribly useful to have some objects protected and others not. Make them all first class citizens and protect all.</p>

<p>I believe that the much smaller size of a good OOP system comes not just by being gently forced to come up with a more thought out design. I think it also has to do with the &#8220;bang per line of code&#8221; you can get with OOP. The object carries with it a lot of significance and intention, its methods suggest the strongest kinds of goals it can carry out, its superclasses can add up to much more code-functionality being invoked than most procedures-on-data-structures. Assignment statements&#8211;even abstract ones&#8211;express very low-level goals, and more of them will be needed to get anything done. Generally, we don&#8217;t want the programmer to be messing around with state, whether simulated or not. The ability to instantiate an object has a considerable effect on code size as well. Another way to think of all this is: though the late-binding of automatic storage allocations doesn&#8217;t do anything a programmer can&#8217;t do, its presence leads both to simpler and more powerful code. OOP is a late binding strategy for many things and all of them together hold off fragility and size explosion much longer than the older methodologies. In other words, human programmers aren&#8217;t Turing machines&#8211;and the less their programming systems require Turing machine techniques the better.</p>

<h3 id='smalltalk_and_children'>Smalltalk and Children</h3>

<p><img alt='Adele holding forth at Jordan Middle Sch' src='figures/turtle.png' /></p>

<p>Now that I have summarized the &#8220;adult&#8221; activities (we were actually only semiadults) in Smalltalk up to 1976, let me return to the summer of &#8216;73, when we were ready to start experiments with children. None of us knew anything about working with children, but we knew that Adele Goldberg and Steve Weyer who were then with Pat Suppes at Stanford had done quite a bit and we were able to entice them to join us.</p>

<p>Since we had no idea how to teach object-oriented programming to children (or anyone else), the first experiments Adele did mimicked LOGO turtle graphics, and she got what appeared to be very similar results. That is to say, the children could get the turtle to draw pictures on the screen, but there seemed to be little happening beyond surface effects. At that time I felt that since the content of personal computing was interactive tools, that the content of this new kind of authoring literacy should be the creation of interactive <em>tools</em> by the children. Procedural turtle graphics just wasn&#8217;t it.</p>

<p>Then Adele came up with a brilliant approach to teaching Smalltalk as an object-oriented language: the &#8220;Joe Book.&#8221; I believe this was partly influenced by Minsky&#8217;s idea that you should teach a programming language holistically from working examples of serious programs.</p>

<p>Several instances of the class box are created and sent messages, culminating with a simple multiprocess animation. After getting kids to guess what a box might be like&#8211;they could come surprisingly close&#8211;they would be shown:</p>

<pre><code>_to box | x y size tilt
(○draw   »    (@place x y turn tilt. square size.
○undraw  »    (@ white. SELF draw. @black)
○turn    »    (SELF undraw. &#39;tilt &lt;- tilt + :. SELF draw)
○grow    »    (SELF undraw. &#39;size &lt;- size + :. SELF draw)
ISNEW    »    (SELF undraw. &#39;size &lt;- size + :. SELF draw)_</code></pre>

<p>What was so wonderful about this idea were the myriad of children&#8217;s projects that could spring off the humble boxes. And some of the earliest were tools! This was when we got really excited. For example, Marion Goldeen&#8217;s (12 yrs old) painting system was a full-fledged tool. A few years later, so was Susan Hamet&#8217;s (12 yrs old) OOP illustration system (with a design that was like the MacDraw to come). Two more were Bruce Horn&#8217;s (15 yrs old) music score capture system and Steve Putz&#8217;s (15 yrs old) circuit design system. Looking back, this could be called another example in computer science of the &#8220;early success syndrome.&#8221; The successes were real, but they weren&#8217;t as general as we thought. They wouldn&#8217;t extend into the future as strongly as we hoped. The children were chosen from the Palo Alto schools (hardly an average background) and we tended to be much more excited about the successes than the difficulties. In part, what we were seeing was the &#8220;hacker phenomenon,&#8221; that, for any given pursuit, a particular 5% of the population will jump into it naturally, while the 80% or so who can learn it in time do not find it at all natural.</p>

<p>We had a dim sense of this, but we kept on having relative successes. We could definitely see that learning the mechanics of the system was not a major problem. The children could get most of it themselves by swarming over the ALTOS with Adele&#8217;s JOE book. The problem seemed more to be that of <em>design.</em></p>

<p><img alt='The author in the interim Dynabook playroom, Adeles planning template for Smalltalk (above) New behavior added by child (below), Marion Goldeens painting program (above) Susan Hamels OO Illustrator (below)' src='figures/author.png' /></p>

<p>It started to hit home in the Spring of &#8216;74 after I taught Smalltalk to 20 PARC nonprogrammer adults. They were able to get through the initial material faster than the children, but just as it looked like an overwhelming success was at hand, they started to crash on problems that didn&#8217;t look to me to be much harder than the ones they had just been doing well on. One of them was a project thought up by one of the adults, which was to make a little database system that could act like a card file or rolodex. They couldn&#8217;t even come close to programming it. I was very surprised because I &#8220;knew&#8221; that such a project was well below the mythical &#8220;two pages&#8221; for end-users we were working within. That night I wrote it out, and the next day I showed all of them how to do it. Still, none of them were able to do it by themselves. Later, I sat in the room pondering the board from my talk. Finally, I counted the number of nonobvious ideas in this little program. They came to 17. And some of them were like the concept of the arch in building design: very hard to discover, if you don&#8217;t already know them.</p>

<p>The connection to literacy was painfully clear. It isn&#8217;t enough to just learn to read and write. There is also a <em>literature</em> that renders <em>ideas.</em> Language is used to read and write about them, but at some point the organization of ideas starts to dominate mere language abilities. And it helps greatly to have some powerful ideas under one&#8217;s belt to better acquire more powerful ideas (Papert 70s). So, we decided we should teach <em>design</em>. And Adele came up with another brilliant stroke to deal with this. She decided that what was needed was an intermediary between the vague ideas about the problem and the very detailed writing and debugging that had to be done to get it to run in Smalltalk. She called the intermediary forms <em>design templates</em>.</p>

<p>Using these the children could look at a situation they wanted to simulate, and decompose it into classes and messages without having to worry just how a method would work. The method planning could then be done informally in English, and these notes would later serve as commentaries and guides to the writing of the actual code. This was a terrific idea, and it worked very well.</p>

<p>But not enough to satisfy us. As Adele liked to point out, it is hard to claim success if only some of the children are successful&#8211;_and_ if a maximum effort of both children and teachers was required to get the successes to happen. Real pedagogy has to work in much less idealistic settings and be considerably more robust. Still, <em>some</em> successes are qualitatively different from <em>no</em> successes. We wanted more, and started to push on the inheritance idea as a way to let novices build on frameworks that could only be designed by experts. We had good reason to believe that this could work because we had been impressed by Lisa van Stone&#8217;s ability to make significant changes to SHAZAM (the five or six page Smalltalk animation tool done by relatively expert adults). Unfortunately, inheritance&#8211;though an incredibly powerful technique&#8211;has turned out to be very difficult for novices (and even professionals) to deal with.</p>

<p><img alt='Circuit system by Steve Putz (age 15), Tangram designs are created by selecting shapes from a menu displayed at the top of the screen. This system was implemented in Smalltalk by a fourteen year old girl Kay 77' src='figures/circuit.png' /></p>

<p>At this point, let me do a look back from the vantage point of today. I&#8217;m now pretty much convinced that our design template approach was a good one after all. We just didn&#8217;t apply it longitudinally enough. I mean by this that there is now a large accumulation of results from many attempts to teach novices programming (Soloway 1989). They all have similar stories that seem to have little to do with the various features of the programming languages used, and everything to do with the difficulties novices have thinking the special way that good programmers think. Even with a much better interface than we had then (and have today), it is likely that this really is actually more like writing than we wanted it to be. Namely, for the &#8220;80%&#8221;, it really has to be learned gradually over a period of years in order to build up the structures that need to be there for design and solution look-ahead.41</p>

<p>The problem is not to get the kids to do stuff&#8211;they love to <em>do</em>, even when they are not sure exactly what they are doing. This correlates well with studies of early learning of language, when much rehearsal is done regardless of whether content is involved. Just <em>doing</em> seems to help. What is difficult is to determine <em>what</em> ideas to put forth and how <em>deeply</em> they should penetrate at a given child&#8217;s developmental level. This confusion still persists for reading and writing of natural language&#8211;and for mathematics&#8211;despite centuries of experience. And it is the main hurdle for teaching children programming. When, in what order and depth, and how should the powerful ideas be taught?</p>

<p>Should we even try to teach programming? I have met hundreds of programmers in the last 30 years and can see no discernible influence of programming on their general ability to think well or to take an enlightened stance on human knowledge. If anything, the opposite is true. Expert knowledge often remains rooted in the environments in which it was first learned&#8211;and most metaphorical extensions result in misleading analogies. A remarkable number of artists, scientists, philosophers are quite dull outside of their specialty (and one suspects within it as well). The first siren&#8217;s song we need to be wary of is the one that promises a connection between an interesting pursuit and interesting thoughts. The music is not in the piano, and it is possible to graduate Juilliard without finding or feeling it.</p>

<p>I have also met a few people for whom computing provides an important new metaphor for thinking about human knowledge and reach. But something else was needed besides computing for enlightenment to happen.</p>

<p>Tools provide a path, a context, and almost an excuse for developing enlightenment, but no tool ever contained it or can dispense it. Cesare Pavese observed: to know the world we must construct it. In other words, <em>we make not just to have, but to know.</em> But the having can happen without most of the knowing taking place.</p>

<p>Another way to look at this is that knowledge is in its least interesting state when it is first being learned. The representations&#8211;whether markings, allusions, or physical controls&#8211;get in the way (almost take over as goals) and must be laboriously and painfully interpreted. From here there are several useful paths, two of which are important and intertwined.</p>

<p>The first is <em>fluency</em>, which in part is the process of building mental structures that disappear the interpretation of the representations. The letters and words of a sentence are experienced as meaning rather than markings, the tennis racquet or keyboard becomes an extension of one&#8217;s body, and so forth. If carried further one eventually becomes a kind of expert&#8211;but without deep knowledge in other areas, attempts to generalize are usually too crisp and ill formed.</p>

<p>The second path is towards taking the knowledge as a <em>metaphor</em> than can illuminate other areas. But without fluency it is more likely that prior knowledge will hold sway and the metaphors from this side will be fuzzy and misleading.</p>

<p>The &#8220;trick,&#8221; and I think that this is what liberal arts educations is supposed to be about, is to get fluent <em>and</em> deep while building relationships with other fluent deep knowledge. Our society has lowered its aims so far that it is happy with &#8220;increases in scores&#8221; without daring to inquire whether any important threshold has been crossed. Being able to read a warning on a pill bottle or write about a summer vacation is not literacy and our society should not treat it so. Literacy, for example, is being able to fluently read and follow the 50 page argument in Paine&#8217;s Common Sense and being able (and happy) to fluently write a critique or defense of it. Another kind of 20th century literacy is being able to hear about a new fatal contagious incurable disease and instantly know that a disastrous exponential relationship holds and early action is of the highest priority. Another kind of literacy would take citizens to their personal computers where they can fluently and without pain build a systems simulation of the disease to use as a comparison against further information.</p>

<p>At the liberal arts level we would expect that connections between each of the fluencies would form truly powerful metaphors for considering ideas in the light of others.</p>

<p>The reason, therefore, that many of us want children to understand computing deeply and fluently is that like literature, mathematics, science, music, and art, it carries special ways of thinking about situations that in contrast with other knowledge and other ways of thinking <em>critically</em> boost our ability to understand our world.</p>

<p>We did not know then, and I&#8217;m sorry to say from 15 years later, that these critical questions still do not yet have really useful answers. But there are some indications. Even very young children can understand and use interactive <em>transformational</em> tools. The first ones are their hands! They can readily extend these experiences to computer objects and making changes to them. They can often imagine what a proposed change will do and not be surprised at the result. Two and three year olds can use the Smalltalk-style interface and manipulate object-oriented graphics. Third graders can (in a few days) learn more than 50 features&#8211;most of these are transformational tools&#8211;of a new system including its user interface. They can answer any question whose answer requires the application of just <em>one</em> of these tools. But it is extremely difficult for them to answer any question that requires <em>two</em> or more transformations. Yet they have no problem applying sequences of transformations, exploring &#8220;forward.&#8221; It is for conceiving and achieving even modest goals requiring several changes that they almost completely lack navigation abilities.</p>

<p>It seems that what needs to be learned and taught is now to package up transformations in twos and threes in a manner similar to learning a strategic game like checkers. The vague sense of a &#8220;threesome&#8221; pointing towards one&#8217;s goal can be a set up for the more detailed work that is needed to accomplish it. This art is possible for a large percentage of the population, but for most, it will need to be learned gradually over several years.</p>

<h2 id='v_197680the_first_modern_smalltalk_76_its_birth_applications_and_improvements'>V. 1976-80&#8211;The first modern Smalltalk (-76), its birth, applications, and improvements</h2>

<p>By the end of 1975 I felt that we were losing our balance&#8211;that the &#8220;Dynabook for children&#8221; idea was slowly dimming out&#8211;or perhaps starting to be overwhelmed by professional needs. In January 1976, I took the whole group to Pajaro Dunes for a three day offsite to bring up the issues and try to reset the compass. It was called &#8220;Let&#8217;s Burn Our Disk Packs.&#8221; There were no shouting matches, the group liked (I would go so far to say: <em>loved</em>) each other too much for that. But we were troubled. I used the old aphorism that &#8220;no biological organism can live in its own waste products&#8221; to plead for a <em>really</em> fresh start: a hw-sw system very different from the ALTO and Smalltalk. One thing we all did agree on was that the current Smalltalk&#8217;s power did not match our various levels of aspiration. I thought we needed something different, as I did not see how OOP by itself was going to solve our end-user problems. Others, particularly some of the grad students, really wanted a better Smalltalk that was faster and could be used for bigger problems. I think Dan felt that a better Smalltalk could be the vehicle for the different system I wanted, but could not describe clearly. The meeting was not a disaster, and we went back to PARC still friends and colleagues, but the absolute cohesiveness of the first four years never rejelled. I started designing a new small machine and language I called the <em>NoteTaker</em> and Dan started to design Smalltalk-76.</p>

<p>The reason I wanted to &#8220;burn the disk packs&#8221; is that I had a very McLuhanish feeling about media and environments: that once we&#8217;ve shaped tools, in his words, they turn around and &#8220;reshape us.&#8221; Of course this is a great idea if the tools are <em>really</em> good and aimed squarely at the issues in question. But the other edge of the sword cuts as deep&#8211;that inadequate tools and environments <em>still</em> reshape our thinking in spite of their problems, in part, because we <em>want</em> paradigms to guide our goals. Strong paradigms like LISP and Smalltalk are so compelling that they <em>eat their young</em>: when you look at an application in either of these two systems, they resemble the systems themselves, not a new idea. When I looked at Smalltalk in 1975, I was looking at something great, but I did not see an enduser language, I did not see a solution to the original goal of a &#8220;reading&#8221; and &#8220;writing&#8221; computer medium for children. I wanted to stop, dynamite everything and start from scratch again.</p>

<p>The <em>NoteTaker</em> was to be a &#8220;laptop&#8221; that could be built in a few years using the (almost) available 16K RAMS (a vast improvement over the 1K RAMS that the ALTO employed). A laptop couldn&#8217;t use a mouse (which I hated anyway) and a tablet seemed awkward (not a lot of room and the stylus could flop out of reach when let go), so I came up with an embedded pointing device I called a &#8220;tabmouse.&#8221; It was a relative pointer and had an <em>up</em> sensor so it could be stroked like a mouse and would also stay where you left it, but it felt like a stylus and used a pantograph mechanism that eliminated the annoying hysteresis bias in the x and y directions that made it hard to use a mouse as a pen. I planned to use a multiprocessor architecture of slow but highly integrated chips as originally specified for the Dynabook and wanted a new bytecoded interpreter for a friendlier and simpler system than Smalltalk-72.</p>

<p><img alt='NoteTaker' src='figures/notetaker.png' /></p>

<p>Meanwhile Dan was proceeding with his total revamp of Smalltalk and along somewhat similar lines (In 78). The first major thing that needed to be done was to get rid of the function/class dualism in favor of a completely intensional definition with every piece of code as an intrinsic method. We had wanted that from the beginning, (and most of the code was already written that way). There were a variety of strong desires for a real inheritance mechanism from Adele and me, from Larry Tesler, who was working on desktop publishing, and from the grad students. Dan had to find a better way than Simula&#8217;s very rigid compile-time conception. It was time to make good on the idea that &#8220;everything was an object,&#8221; which included all the internal &#8220;systems&#8221; objects like &#8220;activation records,&#8221; etc. We were all agreed that the flexible syntax of the earlier Smalltalks was <em>too</em> flexible, and this level of extensibility was not desirable. All of the extensions we liked used various keyword schemes, so Dan came up with a combination keyword/operator syntax that was very flexible, but allowed the language to be read unambiguously by both humans and the machine. This allowed a FLEX machine-like byte-code compiler and efficient interpreter to be defined that ran up to 180 times as fast as the previous direct interpreter. The OOZE VM system could be modified to handle the new objects and its capacity was well matched to the ALTO&#8217;s RAM and disk.</p>

<h3 id='inheritance'>Inheritance</h3>

<p>A word about inheritance. Simula-I had neither classes as objects nor inheritance. Simula-67 added the latter as a generalization to the ALGOL-60 &#8220;block&#8221; structure. This was a great idea. But it did have some drawbacks: minor ones like name clashes in multiple threaded lists (no one uses threaded lists anymore), and major ones like rigidity in the extended type structures, need to qualify types, only a single path of inheritance, and difficulty in adapting to an interactive development system with incremental compiling and other needs for instant changes. Then there were a host of problems that were really outside the scope of Simula&#8217;s goals: having to do with various kinds of modeling and inferencing that were of interest in the world of artificial intelligence. For example, not all useful questions could be answered by following a static chain. Some of them required a kind of &#8220;inheritance&#8221; or &#8220;inferencing&#8221; through dynamically bound &#8220;parts&#8221; (i.e. instance variables). Multiple inheritance also looked important but the corresponding possible clashes between methods of the same name in different superclasses looked difficult to handle, and so forth.</p>

<p>On the other hand, since things can be done with a dynamic language that are difficult with a statically compiled one, I just decided to leave inheritance out as a feature in Smalltalk-72, knowing that we could simulate it back using Smalltalk&#8217;s LISPlike flexibility. The biggest contributor to these AI ideas was Larry Tesler who used what is now called &#8220;slot inheritance&#8221; extensively in his various versions of early desktop publishing systems. Nowadays, this would be called a &#8220;delegation-style&#8221; inheritance scheme (Liberman 84). Danny Bobrow and Terry Winograd during this period were designing a &#8220;frame-based&#8221; AI language called KRL which was &#8220;object-oriented&#8221; and I believe was influenced by early Smalltalk. It had a kind of multiple inheritance&#8211;called <em>perspectives</em>&#8211;which permitted an object to play multiple roles in a very clean way. Many of these ideas a few years later went into PIE, an interesting extension of Smalltalk to networks and higher level descriptions by Ira Goldstein and Bobrow (Goldstein &amp; Bobrow 1980).</p>

<p>By the time Smalltalk-76 came along, Dan Ingalls had come up with a scheme that was Simula-like in its semantics but could be incrementally changed on the fly to be in accord with our goals of close interaction. I was not completely thrilled with it because it seemed that we needed a better theory about inheritance entirely (and still do). For example, inheritance and instancing (which is a kind of inheritance) muddles both pragmatics (such as factoring code to save space) and semantics (used for way too many tasks such as: specialization, generalization, speciation, etc.) Alan Borning employed a multiple inheritance scheme in Thinglab (Borning 1977) which was implemented in Smalltalk-76. But no comprehensive and clean multiple inheritance scheme appeared that was compelling enough to surmount Dan&#8217;s original Simula-like design.</p>

<p>Meanwhile, the running battle with Xerox continued. There were now about 500 ALTOs linked with Ethernets to each other and to Laserprinter and file servers, that used ALTOs as controllers. I wrote many memos to the Xerox planners trying to get them to make plans that included personal computing as one of their main directions. Here is an example:</p>

<h4 id='a_simple_vision_of_the_future'>A Simple Vision of the Future</h4>

<p><em>A Brief Update Of My 1971 Pendery Paper</em></p>

<p>In the 1990&#8217;s there will be millions of personal computers. They will be the size of notebooks of today, have high-resolution flat-screen reflective displays, weigh less than ten pounds, have ten to twenty times the computing and storage capacity of an <em>Alto.</em> Let&#8217;s call them <em>Dynabooks.</em></p>

<p>The purchase price will be about that of a color television set of the era, although most of the machines will be given away by manufacturers who will be marketing the content rather than the container of personal computing.</p>

<p>&#8230;</p>

<p>Though the <em>Dynabook</em> will have considerable local storage and will do most computing locally, it will spend a large percentage of its time hooked to various large, global information utilities which will permit communication with others of ideas, data, working models, as well as the daily chit-chat that organizations need in order to function. The communications link will be by private and public wire and by packet radio, Dynabooks will also by used as servers in the information utilities. They will have enough power to be entirely shaped by software.</p>

<h4 id='the_main_points_of_this_vision'>The Main Points Of This Vision</h4>

<p>* There need only be a few hardware types to handle almost all of the processing activity of a system. * Personal Computers, Communications Links, and Information Utilities are the three critical components of a Xerox future.</p>

<p>&#8230;</p>

<p>In other words, the <em>material</em> of a computer system is the computer itself, <em>all</em> of the <em>content</em> and <em>function</em> is fashioned in software.</p>

<p>There are two important guidelines to be drawn from this:</p>

<p>* Material: If the design and development of the hardware computer material is done as carefully and completely as Xerox&#8217;s development of special light-sensitive alloys, then only one or two computer designs need to be built&#8230; Extra investment in development here will be vastly repaid by simplifying the manufacturing process and providing lower costs through increased volume. * Content: Aside from the wonderful generality of being able to continuously shape new content from the same material, <em>software</em> has three important characteristics:</p>

<pre><code>* the _replication_ time and cost of a content-function is _zero_
* the _development_ time and cost for a content-function is _high_
* the _change_ time and cost for a content-function can be _low_</code></pre>

<p>Xerox <em>must</em> take these several points seriously if it is to survive and prosper in its new business area of information media. If it does, the company has an excellent chance for several reasons:</p>

<p>* Xerox has the financial base to cover the large development costs of a small number of very powerful computer-types and a large number of software functions. * Xerox has the marketing base to sell these functions on a wide enough scale to garner back to itself an incredible profit. * Xerox has working for it an impressively large percentage of the best software designers in the world.</p>

<p>In 1976, Chuck Thacker designed the ALTO III that would use the new 16k chips and be able to fit on a desktop. It could be marketed for about what the large cumbersome special purpose &#8220;word-processors&#8221; cost, yet could do so much more. Nevertheless, in August of 1976, Xerox made a fateful decision: not to bring the ALTO III to market. This was a huge blow to many of us&#8211;even I, who had never really, really thought of the ALTO as anything but a stepping stone to the &#8220;real thing.&#8221; In 1992, the world market for personal computers and workstations was $90 million&#8211;twice as much as the mainframe and mini market, and many times Xerox&#8217;s 1992 gross. The most successful company of this era&#8211;Microsoft&#8211;is not a hardware company, but a software company.</p>

<h3 id='the_smalltalk_user_interface'>The Smalltalk User Interface</h3>

<p>I have been asked by several of the reviewers to say more about the development of the &#8220;Smalltalk-style&#8221; overlapping window user interface since there are now more than 20 million computers in the world that use its descendants. A decent history would be as long as this chapter, and none has been written so far. There is a summary of some of the ideas in (Kay 89)&#8211;let me add a few more points.</p>

<p>All of the elements eventually used in the Smalltalk user interface were already to be found in the sixties&#8211;as different ways to access and invoke the functionality provided by an interactive system. The two major centers of ideas were Lincoln Labs and RAND corp&#8211;both ARPA funded. The big shift that consolidated these ideas into a powerful theory and long-lived examples came because the LRG focus was on children. Hence, we were thinking about learning as being one of the main effects we wanted to have happen. Early on, this led to a 90 degree rotation of the purpose of the user interface from &#8220;access to functionality&#8221; to &#8220;environment in which users learn by doing.&#8221; This new stance could now respond to the echoes of Montessori and Dewey, particularly the former, and got me, on rereading Jerome Bruner, to think beyond the children&#8217;s curriculum to a &#8220;curriculum of the user interface.&#8221;</p>

<p>The particular aim of LRG was to find the equivalent of writing&#8211;that is learning and thinking by doing in a medium&#8211;our new &#8220;pocket universe.&#8221; For various reasons I had settled on &#8220;iconic programming&#8221; as the way to achieve this, drawing on the iconic representations used by many ARPA projects in the sixties. My friend Nicholas Negroponte, an architect, was extremely interested in how environments affected peoples&#8217; work and creativity. He was interested in embedding the new computer magic in familiar surroundings. I had quite a bit of theatrical experience in a past life, and remembered Coleridge&#8217;s adage that &#8220;people attend &#8216;bad theatre&#8217; hoping to forget, people attend &#8216;good theatre&#8217; <em>aching to remember</em>.&#8221; In other words, it is the ability to evoke the audience&#8217;s own intelligence and experiences that makes theatre work.</p>

<p><img alt='Paul Rovner showing the iconic Lincoln Wand ca. 1968' src='figures/paulrovner.png' /> <img alt='The last Smalltalk-72 Interface, Ted Kaehlers iconic painting interface' src='figures/lastsmalltalk72.png' /></p>

<p>Putting all this together, we want an apparently free environment in which exploration causes desired sequences to happen (Montessori); one that allows kinesthetic, iconic, and symbolic learning&#8211;&#8221;_doing_ with <em>images</em> makes <em>symbols</em>&#8221; (Piaget &amp; Bruner); the user is never trapped in a mode (GRAIL); the magic is embedded in the familiar (Negroponte); and which acts as a magnifying mirror for the user&#8217;s own intelligence (Coleridge). It would be a great finish to this story to say that having articulated this we were able to move straightforwardly to the design as we know it today. In fact, the UI design work happened in fits and starts in between feeding Smalltalk itself, designing children&#8217;s experiments, trying to understand iconic construction, and just playing around. In spite of this meandering, the context almost forced a good design to turn out anyway. Just about everyone at PARC at this time had opinions about the UI, ours and theirs. It is impossible to give detailed credit for the hundreds of ideas and discussions. However, the consolidation can certainly be attributed to Dan Ingalls, for listening to everyone, contributing original ideas, and constantly building a design for user testing. I had a fair amount to do with setting the context, inventing overlapping windows, etc., and Adele and I designed most of the experiments. Beyond that, Ted Kaehler, and visitor Ron Baecker made highly valuable contributions. Dave Smith designed, SmallStar, the prototype iconic interface for the Xerox Star product (Smith 83).</p>

<p>Meanwhile, I had gotten Doug Fairbairn interested in the <em>Notetaker</em>. He designed a wonderful &#8220;smart bus&#8221; that could efficiently handle slow multiple processors and the system looked very promising, even though most of the rest of PARC thought I was nuts to abandon the fast bipolar hw of the ALTO. But I couldn&#8217;t see that bipolar was ever going to make it into a laptop or Dynabook. On the other hand I hated the 8-bit micros that were just starting to appear, because of the silliness and naivete of their designs&#8211;there was no hint that anyone who had ever designed software was involved.</p>

<h3 id='smalltalk76'>Smalltalk-76</h3>

<p><img alt='Smalltalk-76' src='figures/smalltalk76.png' /></p>

<p>Dan finished the Smalltalk-76 design November, and he, Dave Robson, Ted Kaehler, and Diana Merry, successfully implemented the system from scratch (which included rewriting all of the existing class definitions) in just seven months. this was such a wonderful achievement that I was bowled over in spite of my wanting to start over. It was fast, lively, could handle &#8220;big&#8221; problems, and was great fun. The system consisted of about 50 classes described in about 180 pages of source code. This included all of the OS functions, files, printing and other Ethernet services, the window interface, editors, graphics and painting systems, and two new contributions by Larry Tesler, the famous browsers for static methods in the inheritance hierarchy and dynamic contexts for debugging in the runtime environment. In every way it was the consolidation of all of our ideas and yearning about Smalltalk in one integrated package. All Smalltalks since have resembled this conception very closely. In many ways, as Tony Hoare once remarked about Algol, Dan&#8217;s Smalltalk-76 was a great improvement on its successors!</p>

<p>Here are two stylish ST-76 classes written by Dan.</p>

<p><img alt='Two stylish ST-76 classes' src='figures/st76.png' /> <img alt='Smalltalk-76 Metaphysics' src='figures/metaphysics.png' /></p>

<p>Notice, particularly in class Window, how the code is expressed as goals for other objects (or itself) to achieve. The superclass Window&#8217;s main job is to notice events and distribute them as messages to its subclasses. In the example, a document window (a subclass of DocWindow) is going to deal with the effects of user interactions. The Window class will notice that the keyboard is active and send a message to itself which will be intercepted by the subclass method. If there is no method the character will be thrown away and the window will flash. In this case, it finds DocWindow method: <strong>keyboard</strong>, which tells the held document to check it out.</p>

<p><img alt='Dan Ingalls, the main implementer of Smalltalk, creator of Smalltalk-76, and his implementation plan (below), Jack Goldman finally uses the system he paid for all those years (with Alan Borning helping), An end-user simulation by Xerox executive in SimKit. Total time including training: 3 hours' src='figures/daningalls.png' /></p>

<p>In January of 1978 Smalltalk-76 had its first real test. CSL had invited the top ten executives of Xerox to PARC for a two day seminar on software, with a special emphasis on complexity and what could be done about it. LRG got asked to give them a hands-on experience in end-user programming so &#8220;they could do &#8216;something real&#8217; over two 1½ hour sessions.&#8221; We immediately decided <em>not</em> to teach them Smalltalk-76 (my &#8220;burn our disk packs&#8221; point in spades), but to create in two months in Smalltalk-76 a rich system especially tailored for adult nonexpert users (Dan&#8217;s point in trumps). We took our &#8220;Simpula&#8221; job shop simulation model as a starting point and decided to build a user interface for a generalized job shop simulation tool that the executives could make into specific dynamic simulations that would act out their changing states by animating graphics on the screen. We called it the Smalltalk SimKit. This was a maximum effort and everyone pitched in. Adele became the design leader in spite of the very recent appearance of a new baby. I have a priceless memory of her debugging away on the SimKit while simultaneously nursing Rachell.</p>

<p>There were many interesting problems to be solved. The system itself was straightforward but it had to be completely sealed off from Smalltalk proper, particularly with regard to error messages. Dave Robson came up with a nice scheme (almost an expert system) to capture complaints from the bowels of Smalltalk and translated them into meaningful SimKit terms. There were many user interface details&#8211;some workaday, like making new browsers that could only look at the four SimKit classes (Station, Worker, Job, Report), and some more surprising as when we tried it on ten PARC nontechnical adults of about the same age and found that they couldn&#8217;t read the screen very well. The small fonts our thirtysomething year-old eyes were used to didn&#8217;t work for those in their 50s. This led to a nice introduction to the system in which the executives were encouraged to customize the screen by choosing among different fonts and sizes with the side effect that they learned how to use the mouse unselfconsciously.</p>

<p>On the morning of the &#8220;big day&#8221; Ted Kaehler decided to make a change in the virtual memory system OOZE to speed it up a little. We all held our breaths, but such was the clarity of the design and the confidence of the implementers that it did work, and the executive hands-on was a howling success. About an hour into the first session one of the VPs (who had written a few programs in FORTRAN 15 years before) finally realized he was programming and mused &#8220;so it&#8217;s finally come to this.&#8221; Nine out of the ten executives were able to finish a simulation problem that related to their specific interests. One of the most interesting and sophisticated was a PC board production line done by the head of a Xerox owned company using actual figures (that he carried around in his head) to prime a model that could not be solved easily by closed form mathematics&#8211;it revealed a serious flaw in the disposition of workers given the line&#8217;s average probability of manufacturing defects.</p>

<p><img alt='Alan Bornings Thinglab, a constraint-based iconic problem solver, Smalltalk-76 hierarchical class browser designed and built by Larry Tesler, The authors pen-based interface for ST-76' src='figures/thinglab.png' /></p>

<p>Another important system done at this time was Alan Borning&#8217;s Thinglab (Borning 1979)&#8211;the first serious attempt to go beyond Ivan Sutherland&#8217;s Sketchpad. Alan devised a very nice approach for dealing with constraints that did not require the solver to be omniscient (or able to solve Fermat&#8217;s last theorem).</p>

<p>We could see that the &#8220;pushing&#8221; style of Smalltalk could eventually be replaced by a &#8220;pulling&#8221; style that was driven by changes to values that different methods were based on. This was an old idea but Thinglab showed how the object-oriented definition could be used to automatically limit the contexts for event-driven processing. And we soon discovered that &#8220;prototypes&#8221; were more hospitable than classes, and that multiple inheritance would be well served if there were classes for methods that knew generally what they were supposed to be about (inspired by Pat Winston&#8217;s 2nd order models).</p>

<p>Meanwhile, the <em>NoteTaker</em> was getting realler, bigger, and slower. By this time the Western Digital emulation-style chips I hoped to used showed signs of being &#8220;diffusion-ware,&#8221; and did not look like they would really show up. We started looking around for something that we could count on, even if it didn&#8217;t have a good architecture. In 1978, the best candidate was the Intel 8086, a 16-bit chip (with many unfortunate remnants of the 8008 and 8080), but with (barely) enough capacity to do the job&#8211;we would need three of them to make up for the ALTO, one for the interpreter, one for bitmapped graphics, and one for i/o (networking, etc).</p>

<p>Dan had been interested in the <em>NoteTaker</em> all along and wanted to see if he could make a version of Smalltalk-76 that could be the <em>NoteTaker</em> system. In order for this to happen it would have to run in 256K, the maximum amount of RAM that we had planned for the machine. None of the NOVA-like emulated &#8220;machine-code&#8221; from the ALTO could be brought over, and it had to fit in memory as well&#8211;there would only be floppies, no swapping memory existed. This challenge led to some excellent improvements in the system design. Ted Kaehler&#8217;s system tracer (which could write out new virtual memories from old ones) was used to clone Smalltalk-76 into the <em>NoteTaker</em>. The indexed object table (as was used in early Smalltalk-80) first appeared here to simplify object access. An experiment in stacking contexts contiguously was tried: to save space and gain speed. Most of the old machine code was rewritten in Smalltalk and the total machine kernel was reduced to 6K bytes of (the not very strong) 8086 code.</p>

<p>All of the re-engineering had an interesting effect. Though the 8086 was not as good at bitblt as the ALTO (and much of the former machine code to assist graphics was now in Smalltalk), the overall interpreter was about twice as fast as the ALTO version (because not all the Smalltalk byte-code interpreter would fit into the 4k microcode memory on the ALTO). With various kinds of tricks and tuning, graphics display was &#8220;largely compensated&#8221; (in Dan&#8217;s words). This was mainly because the ALTO did not have enough microcode memory to take in all of the Smalltalk emulation code&#8211;some of it had to be rendered in emulated &#8220;NOVA&#8221; code which forced two layers of interpretation. In fact, the <em>Notetaker</em> worked extremely well, though it would have crushed any lap. It had hopped back on the desk, and looked suspiciously like miniCOM (and several computers that would appear a few years later). It really did run on batteries and several of us had the pleasure of taking <em>NoteTaker</em> on a plane and running an object-oriented system with a windowed interface at 35,000 feet.</p>

<p><img alt='Design for NoteTaker interface (Ka 79), What Steve Jobs saw, Multiviews on complex structure by Trygive Reeskaug (above) Multimedia documents by Bob Flegal and Dlana Merry (below)' src='figures/designfornotetaker.png' /></p>

<p>We eventually built about 10 of the machines, and though in many senses an engineering success, what had to be done to make them had once again squeezed out the real end-users for whom it was originally aimed. If Xerox (and PARC) as a whole had believed in these smaller scale ideas, we could have put much more silicon muscle behind the dreams and successfully built them in the 70&#8217;s when they were first possible. It was a bitter disappointment to have to get the wrong kind of CPU from Intel and the wrong kind of display from HP because there was not enough corporate will to take advantage of internal technological expertise.</p>

<p>By now it was already 1979, and we found ourselves doing one of our many demos, but this time for a very interested audience: Steve Jobs, Jef Raskin, and other technical people from Apple. They had started a project called <em>Lisa</em> but weren&#8217;t quite sure what it should be like, until Jeff said to Steve, &#8220;You should really come over to PARC and see what they are doing.&#8221; Thus, more than eight years after overlapping windows had been invented and more than six years after the ALTO started running, the people who could really do something about the ideas, finally got to to see them. The machine used was the Dorado, a very fast &#8220;big brother&#8221; of the ALTO, whose Smalltalk microcode had been largely written by Bruce Horn, one of our original &#8220;Smalltalk kids&#8221; who was still only a teen-ager. Larry Tesler gave the main part of the demo with Dan sitting in the copilot&#8217;s chair and Adele and I watched from the rear. One of the best parts of the demo was when Steve Jobs said he didn&#8217;t like the blt-style scrolling we were using and asked if we could do it in a smooth continuous style. In less than a minute Dan found the methods involved, made the (relatively major) changes and scrolling was now continuous! This shocked the visitors, especially the programmers among them, as they had never seen a really powerful incremental system before.</p>

<p>Steve tried to get and/or buy the technology from Xerox (which was one of Apple&#8217;s minority venture capitalists), but Xerox would neither part with it nor would come up with the resources to continue to develop it in house by funding a better <em>NoteTaker</em> cum Smalltalk.</p>

<h2 id='vi_198083the_release_version_of_smalltalk_80'>VI. 1980-83&#8211;The release version of Smalltalk (-80)</h2>

<p>&#8220;The greatest sin in Art is not Boredom,<br />as is commonly supposed, but lack of<br />Proportion&#8221; &#8211; Paul Hindemith</p>

<p>As Dan said &#8220;the decision not to continue the <em>NoteTaker</em> project added motivation to release Smalltalk widely.&#8221; But not for me. By this time I was both happy about the cleanliness and elegance of the Smalltalk conception as realized by Dan and the others, and sad that it was farther away than ever from the children&#8211;it came to me as a shock that no child had programmed in any Smalltalk since Smalltalk-76 made its debut. Xerox (and PARC) were now into &#8220;workstations&#8221; as things in themselves&#8211;but I still wanted &#8220;playstations&#8221;. The romance of the Dynabook seemed less within grasp, paradoxically just when the various needed technologies were starting to be commercially feasible&#8211;some of them, unfortunately, like the flat-screen display, abandoned to the Japanese by the US companies who had invented them. This was a major case of &#8220;snatching defeat from the jaws of victory.&#8221; Larry Tesler decided that Xerox was never going to &#8220;get it&#8221; and was hired by Steve Jobs in May 1980 to be a principal designer of the <em>Lisa</em>. I agreed, had a sabbatical coming, and took it.</p>

<p>Adele decided to drive the documentation and release process for a new Smalltalk that could be distributed widely almost regardless of the target hardware. Only a few changes had to be made to the NoteTaker Smalltalk-78 to make a releasable system. Perhaps the change that was most ironic was to turn the custom fonts that made Smalltalk more readable (and were a hallmark of the entire PARC culture) back into standard pedestrian ASCII characters. According to Peter Deutsch this &#8220;met with heated opposition within the group at the time, but has turned out to be essential for the acceptance of the system in the world.&#8221; Another change was to make blocks more like lambda expressions which, as Peter Deutsch was to observe nine yeas later: &#8220;In retrospect, this proliferation of different kinds of instantiations and scoping was probably a bad idea.&#8221; The most puzzling strange idea&#8211;at least to me as a new outsider&#8211;was the introduction of metaclasses (really just to make instance initialization a little easier&#8211;a very minor improvement over what Smalltalk-76 did quite reasonably already). Peter&#8217;s 1989 comment is typical and true: &#8220;metaclasses have proven confusing to many users, and perhaps in the balance more confusing than valuable.&#8221; In fact, in their PIE system, Goldstein and Bobrow had already implemented in Smalltalk an &#8220;observer language&#8221;, somewhat following the view-oriented approach I had been advocating and in some ways like the &#8220;perspectives&#8221; proposed in KRL (Goldstein). Once one can view an instance via multiple perspectives even &#8220;semi-metaclasses&#8221; like Class Class and Class Object are not really necessary since the object-role and instance-of-a-class-role are just different views and it is easy to deal with life-history issues including instantiation. This was there for the taking (along with quite a few other good ideas), but it wasn&#8217;t adopted. My guess is that Smalltalk had moved into the final phase I mentioned at the beginning of this story, in which a way of doing things finally gets canonized into an inflexible belief structure.</p>

<h3 id='coda'>Coda</h3>

<p>One final comment. Hardware is really just software crystallized early. It is there to make program schemes run as efficiently as possible. But far too often the hardware has been presented as a given and it is up to software designers to make it appear reasonable. This has caused low-level techniques and excessive optimization to hold back progress in program design. As Bob Barton used to say: &#8220;Systems programmers are high priests of a low cult.&#8221;</p>

<p>One way to think about progress in software is that a lot of it has been about finding ways to <em>late-bind</em>, then waging campaigns to convince manufacturers to build the ideas into hardware. Early hardware had wired programs and parameters; random access memory was a scheme to late-bind them. Looping and indexing used to be done by address modification in storage; index registers were a way to late-bind. Over the years software designers have found ways to late-bind the locations of computations&#8211;this led to base/bounds registers, segment relocation, page MMUs, migratory processes, and so forth. Time-sharing was held back for years because it was &#8220;inefficient&#8221;&#8211; but the manufacturers wouldn&#8217;t put MMUs on the machines, universities had to do it themselves! Recursion late-binds parameters to procedures, but it took years to get even rudimentary stack mechanisms into CPUs. Most machines still have no support for dynamic allocation and garbage collection and so forth. In short, most hardware designs today are just re-optimizations of moribund architectures.</p>

<p>From the late-binding perspective, OOP can be viewed as a comprehensive technique for late-binding as many things as possible: the <em>mix</em> of state and process in a set of behaviors, <em>where</em> they are located, <em>what</em> they are called, <em>when</em> and <em>why</em> the are invoked, <em>which</em> HW is used, etc., and more subtle, the <em>strategies</em> used in the OOP scheme itself. The art of the wrap is the art of the trap.</p>

<p>Consider the two cases that must be handled efficiently in order to completely wrap objects. It would be terrible if <em>a + b</em> incurred <em>any</em> overhead if <em>a</em> and <em>b</em> were bound, say, to &#8220;3&#8221; and &#8220;4&#8221; in a form that could be handled by the ALU. The operations should occur full speed using look-aside logic (in the simplest scheme a single <em>and</em> gate) to trap if the operands aren&#8217;t compatible with the ALU. Now all elementary operations that have to happen fast have been wrapped without slowing down the machine.</p>

<p>The second case happens if the trap has determined the objects in questions are too complicated for the ALU. Now the HW has to dynamically find a method that can handle the objects. This is very similar to indexing&#8211;the class of one of the objects is &#8220;indexed&#8221; by the desired method-selector in a slightly more general way. In other words the <em>virtual-address</em> of a method is <code>&lt;class&gt;&lt;selector&gt;</code>. Since most HW today does a virtual address translation of some kind to find the real address&#8211;a trap&#8211;it is quite possible to hide the overhead of the OOP dispatch in the MMU overhead that has already been rationalized.</p>

<p>Again, the whole point of OOP is <em>not</em> to have to worry about what is <em>inside</em> an object. Objects made on different machines and with different languages <em>should</em> be able to talk to each other&#8211;and will <em>have to</em> in the future. Late-binding here involves trapping incompatibilities into <em>re</em>compatibility methods&#8211;a good discussion of some of the issues is found in (Popek 1984).</p>

<p>Staying with the metaphor of late-binding, what further late-binding schemes might we expect to see? One of the nicest late-binding schemes that is being experimented with is the <em>metaobject protocol</em> work at Xerox PARC (Kiczales 1991). The notion is that the language designer&#8217;s choice for the internal representation of instances, variables, etc., may not cover what the implementer needs, so within a <em>fixed</em> semantics they allow the implementer to give the system strategies&#8211;for example, using a hashed lookup for slots in an instance instead of direct indexing. These are then efficiently compiled and extend the base implementation of the system. This is a direct descendant of similar directions from the past of Simula, FLEX, CDL, Smalltalk, and Actors.</p>

<p>Another late-binding scheme that is already necessary is to get away from direct protocol matching when a new object shows up in a system of objects. In other words, if someone sends you an object from halfway around the world it will be unusual if it conforms to your local protocols. At some point it will be easier to have it carry even more information about itself&#8211;enough so its specifications can be &#8220;understood&#8221; and its configuration into your mix done by the more subtle matching of <em>inference</em>.</p>

<p>A look beyond OOP as we know it today can also be done by thinking about late-binding. Prolog&#8217;s great idea is that it doesn&#8217;t need binding to values in order to carry out computations (Col). The variable is an object and a web of partial results can be built to be filled in when a binding is finally found. Eurisko (Lenat) constructs its methods&#8211;and modifies its basic strategies&#8211;as it tries to solve a problem. Instead of a problem looking for methods, the methods look for problems&#8211;and Eurisko looks for the methods of the methods. This has been called &#8220;opportunistic programming&#8221;&#8211;I think of it as a drive for more enlightenment, in which problems get resolved as part of the process.</p>

<p>This higher computational finesse will be needed as the next paradigm shift&#8211;that of pervasive networking&#8211;takes place over the next five years. Objects will gradually become active agents and will travel the networks in search of useful information and tools for their managers. Objects brought back into a computational environment from halfway around the world will not be able to configure themselves by direct protocol matching as do objects today. Instead, the objects will carry much more information about themselves in a form that permits <em>inferential</em> docking. Some of the ongoing work in specification can be turned to this task (Guttag, Goguen).</p>

<p>Tongue in cheek, I once characterized progress in programming languages as kind of &#8220;sunspot&#8221; theory, in which major advances took place about every 11 years. We started with machine code in 1950, then in 1956 FORTRAN came along as a &#8220;better old thing&#8221; which if looked at as &#8220;almost a new thing&#8221; became the precursor of ALGOL-60 in 1961. In 1966, SIMULA was the &#8220;better old thing,&#8221; which if looked at as &#8220;almost a new thing&#8221; became the precursor of Smalltalk in 1972.</p>

<p>Everything seemed set up to confirm the &#8220;theory&#8221; once more: in 1978 Eurisko was in place as the &#8220;better old thing&#8221; that was &#8220;almost a new thing&#8221;. But 1983&#8211;and the whole decade&#8211;came and went without the &#8220;new thing&#8221;. Of course, such a theory is silly anyway&#8211;and yet, I think the enormous commercialization of personal computing has smothered much of the kind of work that used to go on in universities and research labs, by sucking the talented kids towards practical applications. With companies so risk-adverse towards doing their own HW, and the HW companies betraying no real understanding of SW, the result has been a great step backwards in most respects.</p>

<p>A twentieth century problem is that technology has become too &#8220;easy&#8221;. When it was hard to do <em>anything</em> whether good or bad, enough time was taken so that the result was usually good. Now we can make things almost trivially, especially in software, but most of the designs are trivial as well. This is inverse vandalism: the making of things because you can. Couple this to even less sophisticated buyers and you have generated an exploitation marketplace similar to that set up for teenagers. A counter to this is to generate enormous dissatisfaction with one&#8217;s designs using the entire history of human art as a standard and goal. Then the trick is to decouple the dissatisfaction from self worth&#8211;otherwise it is either too depressing or one stops too soon with trivial results.</p>

<p><img alt='Dave Robson' src='figures/daverobson.png' /></p>

<p>I will leave the story of early Smalltalk in 1981 when an extensive series of articles on Smalltalk-80 was published in <em>Byte</em> magazine, (Byte 1981) followed by Adele&#8217;s and Dave Robson&#8217;s books (Goldberg 1983) and the official release of the system in 1983. Now programmers could easily implement the virtual machine without having to reinvent it, and, in several cases, groups were able to roll their own <em>image</em> of basic classes. In spite of having to run almost everywhere on moribund HW architectures, Smalltalk has proliferated amazingly well (in part because of tremendous optimization efforts on these machines) (Deutsch 83). As far as I can tell, it still seems to be the most widely used system that claims to be object-oriented. It is incredible to me that no one since has come up with a qualitatively better idea that is as simple, elegant, easy to program, practical, and comprehensive. (It&#8217;s a pity that we didn&#8217;t know about PROLOG then or vice versa, the combinations of the two languages done subsequently are quite intriguing.)</p>

<p>While justly applauding Dan, Adele and the others that made Smalltalk possible, we must wonder at the same time: where are the Dans and the Adeles of the &#8217;80s and &#8217;90s that will take us to the next stage?</p>

<p><img alt='Byte Magazine, August 1981' src='figures/byte.png' /></p>
            </div>
	  </li>
	  <hr>
	  <h4>2013.05.06</h4>
	</ul>

	<div id="footer">
          <p>
	    <a href="http://www.lachrymology.org">Home</a> | 
	    <a href="http://twitter.com/fogus">@fogus</a>
	  </p>
	</div>
      </div>
    </div>
  </body>
</html>

